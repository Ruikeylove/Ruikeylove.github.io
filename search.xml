<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Yelp数据集数据分析</title>
      <link href="/posts/9798671.html"/>
      <url>/posts/9798671.html</url>
      
        <content type="html"><![CDATA[<h1 id="Yelp数据集数据分析"><a href="#Yelp数据集数据分析" class="headerlink" title="Yelp数据集数据分析"></a>Yelp数据集数据分析</h1><p>数据说明</p><ul><li>business_id门店ID</li><li>Date    日期</li><li>Rating    评分</li><li>Content    评价内容</li><li>Review_auther    点评作者</li><li>Review_image    点评插图</li><li>Reactions    互动</li><li>Replies    回复</li><li>review_order    点评序号（针对同一家店）</li><li>Eelite_status    表示点评作者是否具有elite标识</li><li>check-in_status    表示点评作者是否在门店办理了入住手续</li><li>business_name    被点评的门店名称</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置matplotlib字体为SimHei</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 正确显示负号</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据集文件路径</span></span><br><span class="line">file_path = <span class="string">&quot;C:\\Users\\28696\\Desktop\\人工智能\\yelp\\Yelp businesses reviews.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">df = pd.read_csv(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据清洗</span></span><br><span class="line">df.dropna(subset=[<span class="string">&#x27;Rating&#x27;</span>], inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="1、评分分布与变化趋势："><a href="#1、评分分布与变化趋势：" class="headerlink" title="1、评分分布与变化趋势："></a>1、评分分布与变化趋势：</h3><p>分析整个数据集中评分的平均值、中位数、标准差等统计指标<br>了解整体评分水平</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算基本统计指标</span></span><br><span class="line">mean_rating = df[<span class="string">&#x27;Rating&#x27;</span>].mean()</span><br><span class="line">median_rating = df[<span class="string">&#x27;Rating&#x27;</span>].median()</span><br><span class="line">std_dev_rating = df[<span class="string">&#x27;Rating&#x27;</span>].std()</span><br><span class="line">min_rating = df[<span class="string">&#x27;Rating&#x27;</span>].<span class="built_in">min</span>()</span><br><span class="line">max_rating = df[<span class="string">&#x27;Rating&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;平均评分: <span class="subst">&#123;mean_rating&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;中位数评分: <span class="subst">&#123;median_rating&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;标准差: <span class="subst">&#123;std_dev_rating&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最小评分: <span class="subst">&#123;min_rating&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最大评分: <span class="subst">&#123;max_rating&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>平均评分: 3.869中位数评分: 5.0标准差: 1.4317433041187548最小评分: 1最大评分: 5</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制评分分布图</span></span><br><span class="line">df[<span class="string">&#x27;Rating&#x27;</span>].hist(bins=<span class="number">20</span>, alpha=<span class="number">0.7</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;评分分布&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;评分&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;数量&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/da33c8886c5d49f93ee0dda68486888f.png" alt="output 6 0"><br>​    </p><p>时间趋势分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 时间趋势分析</span></span><br><span class="line">monthly_ratings = df[<span class="string">&#x27;Rating&#x27;</span>].resample(<span class="string">&#x27;M&#x27;</span>).mean().plot()</span><br><span class="line">monthly_ratings.set_title(<span class="string">&#x27;每月平均评分&#x27;</span>)</span><br><span class="line">monthly_ratings.set_xlabel(<span class="string">&#x27;日期&#x27;</span>)</span><br><span class="line">monthly_ratings.set_ylabel(<span class="string">&#x27;平均评分&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/8a15041dac4ce1ea281a64225b762626.png" alt="output 8 0"><br>​    </p><h2 id="2、Elite用户影响力分析："><a href="#2、Elite用户影响力分析：" class="headerlink" title="2、Elite用户影响力分析："></a>2、Elite用户影响力分析：</h2><p>分析Elite（精英）用户的评论数量、内容特点以及对其他用户Reactions（点赞、收藏等）的影响<br>进行Elite用户影响力分析，可以从以下几个步骤入手：<br>（1）筛选Elite用户评论：从数据集中筛选出标记为Elite的用户评论。<br>（2）计算Elite用户评论数量：统计Elite用户评论的总数。<br>（3）分析Elite用户评论内容：可以对Elite用户的评论文本进行文本分析，比如词频分析、情感分析等。<br>（4）分析Elite用户评论的Reactions：统计Elite用户评论的点赞、收藏等互动数量，并与其他用户进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 &#x27;Eelite_status&#x27; 字段</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;Eelite_status&#x27;</span>].unique())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出 &#x27;Eelite_status&#x27; 不是 NaN 且包含 &#x27;Elite&#x27; 的评论</span></span><br><span class="line">elite_reviews = df[pd.notnull(df[<span class="string">&#x27;Eelite_status&#x27;</span>]) &amp; (df[<span class="string">&#x27;Eelite_status&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;Elite&#x27;</span>, <span class="keyword">case</span>=<span class="literal">False</span>, na=<span class="literal">False</span>))]</span><br></pre></td></tr></table></figure><pre><code>[nan &#39;Elite from 2023&#39;]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算Elite用户评论数量</span></span><br><span class="line">elite_review_count = elite_reviews.shape[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Elite用户评论数量: <span class="subst">&#123;elite_review_count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制Elite用户评论数量的直方图</span></span><br><span class="line">elite_reviews[<span class="string">&#x27;Rating&#x27;</span>].hist(bins=<span class="number">20</span>, alpha=<span class="number">0.7</span>, color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Elite用户评分分布&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;评分&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;数量&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制Elite用户评论的Reactions（互动，如点赞、收藏等）数量直方图</span></span><br><span class="line">elite_reviews[<span class="string">&#x27;Reactions&#x27;</span>].hist(bins=<span class="number">20</span>, alpha=<span class="number">0.7</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Elite用户评论Reactions数量&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Reactions数量&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;数量&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>Elite用户评论数量: 3</code></pre><p><img src="https://file.imgcc.cloud/images/2024/08/13/22577e4d627718e3d43843b42bdfd045.png" alt="output 11 1"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/25c1cbdfa0d92e91195d6bf7d78f27eb.png" alt="output 11 2"></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>（1）评分较高：Elite用户普遍给出较高的评分，这可能表明他们对商户的整体体验感到满意。<br>（2）Reactions认可：某些评论在特定的Reactions类别中获得了认可，这可能表明这些评论在某些特定方面（如幽默感、酷感）特别突出或引人注目。</p><h4 id="进一步分析建议"><a href="#进一步分析建议" class="headerlink" title="进一步分析建议"></a>进一步分析建议</h4><ul><li>深入分析Reactions：可以进一步分析哪些评论获得了较多的Reactions，特别是那些在多个类别中都获得认可的评论。</li><li>评论内容分析：对Elite用户的评论内容进行文本分析，识别他们特别关注或满意的方面。</li><li>时间趋势分析：如果数据集包含时间戳，可以分析Elite用户评分和Reactions随时间的变化趋势，了解是否有季节性或趋势性的变化。</li></ul><h3 id="3、图片对评论的影响力分析："><a href="#3、图片对评论的影响力分析：" class="headerlink" title="3、图片对评论的影响力分析："></a>3、图片对评论的影响力分析：</h3><p>统计Review_image存在的比例，分析包含图片的评论与无图片评论的Rating差异，了解图片是否对评分有显著影响<br>要进行图片对评论影响力分析，我们可以采取以下步骤：<br>（1）统计包含图片的评论比例：计算数据集中包含图片（Review_image 字段非空）的评论数量，并与总评论数量进行比较。<br>（2）分析包含图片的评论与无图片评论的评分差异：比较包含图片的评论的评分（Rating）与无图片评论的评分，看是否存在显著差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算包含图片的评论比例</span></span><br><span class="line">image_reviews = df[df[<span class="string">&#x27;Review_image&#x27;</span>].notnull()]</span><br><span class="line">no_image_reviews = df[df[<span class="string">&#x27;Review_image&#x27;</span>].isnull()]</span><br><span class="line"></span><br><span class="line">total_reviews = df.shape[<span class="number">0</span>]</span><br><span class="line">image_review_count = image_reviews.shape[<span class="number">0</span>]</span><br><span class="line">no_image_review_count = no_image_reviews.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">image_review_percentage = (image_review_count / total_reviews) * <span class="number">100</span></span><br><span class="line">no_image_review_percentage = (no_image_review_count / total_reviews) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;包含图片的评论比例: <span class="subst">&#123;image_review_percentage:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;不包含图片的评论比例: <span class="subst">&#123;no_image_review_percentage:<span class="number">.2</span>f&#125;</span>%&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算包含图片的评论的平均评分</span></span><br><span class="line">mean_rating_image = image_reviews[<span class="string">&#x27;Rating&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;包含图片的评论的平均评分: <span class="subst">&#123;mean_rating_image:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不包含图片的评论的平均评分</span></span><br><span class="line">mean_rating_no_image = no_image_reviews[<span class="string">&#x27;Rating&#x27;</span>].mean()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;不包含图片的评论的平均评分: <span class="subst">&#123;mean_rating_no_image:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制包含图片和不包含图片评论的评分直方图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.hist([image_reviews[<span class="string">&#x27;Rating&#x27;</span>], no_image_reviews[<span class="string">&#x27;Rating&#x27;</span>]], bins=<span class="number">20</span>, alpha=<span class="number">0.7</span>, label=[<span class="string">&#x27;有图片&#x27;</span>, <span class="string">&#x27;无图片&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;包含图片和不包含图片评论的评分分布&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;评分&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;数量&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>包含图片的评论比例: 17.90%不包含图片的评论比例: 82.10%包含图片的评论的平均评分: 4.21不包含图片的评论的平均评分: 3.79</code></pre><p><img src="https://file.imgcc.cloud/images/2024/08/13/3c59118802a4ff7e52fba1206b008566.png" alt="output 14 1"></p><h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><ul><li>图片对评分的影响：包含图片的评论平均评分显著高于不包含图片的评论，这可能表明图片在一定程度上提高了用户的满意度，从而影响了他们的评分。这可能是因为图片可以更直观地展示商户的产品或服务，增加了评论的可信度和吸引力。</li><li>用户行为：较少的用户选择在评论中添加图片，但这些用户可能更倾向于给出更高的评分。这可能意味着他们对商户的体验非常满意，希望通过图片进一步支持他们的正面评价。</li></ul><h4 id="进一步分析建议-1"><a href="#进一步分析建议-1" class="headerlink" title="进一步分析建议"></a>进一步分析建议</h4><ul><li>深入分析图片内容：可以进一步分析图片的内容，了解哪些类型的图片（如食品、环境、服务等）更常见，以及这些图片是否与更高的评分相关联。</li><li>评论文本分析：结合评论文本内容，分析图片评论中常见的关键词或短语，了解用户在哪些方面特别满意。</li><li>时间因素：如果数据集包含时间戳，可以分析不同时间段内图片评论的比例和评分是否有变化，了解是否存在季节性或趋势性的影响。</li></ul><h3 id="4、点评序号与评分关系："><a href="#4、点评序号与评分关系：" class="headerlink" title="4、点评序号与评分关系："></a>4、点评序号与评分关系：</h3><p>观察review_order与Rating之间的关系，研究随着点评数量的增长，新近点评的评分是否趋于稳定、是否存在“新鲜感”效应（即新开业或新加入Yelp的商家初期评分偏高）<br>要分析点评序号（review_order）与评分（Rating）之间的关系步骤如下：</p><ul><li>排序：根据点评序号对数据进行排序，确保点评序号是连续的。</li><li>计算平均评分：按点评序号分组，计算每个组别的平均评分。来确保每个商户的评分是按时间顺序计算的</li><li>绘制趋势图：绘制点评序号与平均评分的关系图，观察评分是否趋于稳定或存在“新鲜感”效应。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置matplotlib字体为SimHei</span></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.family&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 正确显示负号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你的数据集文件路径</span></span><br><span class="line">file_path = <span class="string">&quot;C:\\Users\\28696\\Desktop\\人工智能\\yelp\\Yelp businesses reviews.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">df = pd.read_csv(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据清洗</span></span><br><span class="line">df.dropna(subset=[<span class="string">&#x27;Rating&#x27;</span>, <span class="string">&#x27;review_order&#x27;</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保review_order是整数类型，同时处理NaN值</span></span><br><span class="line">df[<span class="string">&#x27;review_order&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;review_order&#x27;</span>], errors=<span class="string">&#x27;coerce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤掉非有限值</span></span><br><span class="line">df = df[pd.isna(df[<span class="string">&#x27;review_order&#x27;</span>]) == <span class="literal">False</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按business_id分组，并按review_order排序</span></span><br><span class="line">df_sorted = df.sort_values(by=[<span class="string">&#x27;business_id&#x27;</span>, <span class="string">&#x27;review_order&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个商户的评分平均值</span></span><br><span class="line">average_ratings = df_sorted.groupby(<span class="string">&#x27;business_id&#x27;</span>)[<span class="string">&#x27;Rating&#x27;</span>].rank(method=<span class="string">&#x27;min&#x27;</span>).reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制点评序号与评分的关系图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> business_id, group <span class="keyword">in</span> df_sorted.groupby(<span class="string">&#x27;business_id&#x27;</span>):</span><br><span class="line">    plt.plot(group[<span class="string">&#x27;review_order&#x27;</span>], group[<span class="string">&#x27;Rating&#x27;</span>], marker=<span class="string">&#x27;o&#x27;</span>, label=<span class="string">f&#x27;Business <span class="subst">&#123;business_id&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;点评序号与评分关系&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;点评序号&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;评分&#x27;</span>)</span><br><span class="line">plt.legend(title=<span class="string">&#x27;商户ID&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/a9fdf6fcd1577b1d0af0bfa2dbd702da.png" alt="output 17 0"><br>​    </p><h4 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h4><ul><li>评分趋势：如果评分随着点评序号的增加而趋于稳定，这可能表明用户对商户的评价逐渐趋于一致，没有明显的“新鲜感”效应。</li><li>新鲜感效应：如果初期评分较高，随着点评数量的增加评分逐渐下降，这可能表明存在“新鲜感”效应，即新开业或新加入Yelp的商家初期评分偏高。</li></ul><h4 id="进一步分析建议-2"><a href="#进一步分析建议-2" class="headerlink" title="进一步分析建议"></a>进一步分析建议</h4><ul><li>时间序列分析：考虑时间因素，分析评分随时间的变化趋势。可以使用时间序列分析方法，如ARIMA模型，来预测评分的变化。</li><li>商户类别分析：分析不同类别的商户是否存在不同的评分趋势。例如，餐饮业和服务业的评分趋势可能有所不同。</li><li>用户行为分析：结合用户的行为数据（如用户评分习惯、评论频率等），分析用户行为对评分的影响。</li><li>文本分析：对评论内容进行文本分析，提取关键词或情感倾向，分析评论内容与评分之间的关系。</li><li>聚类分析：对商户进行聚类分析，找出评分趋势相似的商户群体，分析其共同特征。</li><li>异常值检测：检测评分数据中的异常值，分析这些异常值背后的原因，如是否是恶意评分或虚假评论。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学建模国赛赛题总结</title>
      <link href="/posts/80760644.html"/>
      <url>/posts/80760644.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、近年赛题学习总结"><a href="#一、近年赛题学习总结" class="headerlink" title="一、近年赛题学习总结"></a>一、近年赛题学习总结</h2><div class="table-container"><table><thead><tr><th style="text-align:center">年份</th><th style="text-align:center">题目</th><th style="text-align:center">模型算法</th></tr></thead><tbody><tr><td style="text-align:center">2018A</td><td style="text-align:center">高温作业专用服装设计</td><td style="text-align:center">单、双目标规划、偏微分方程、模拟退火算法</td></tr><tr><td style="text-align:center">==2018B==</td><td style="text-align:center">==智能RGV的动态调度策略==</td><td style="text-align:center">==双目标规划、0-1规划、贪心算法、动态调度模型==</td></tr><tr><td style="text-align:center">2018C</td><td style="text-align:center">大型百货商场会员画像描绘</td><td style="text-align:center">RFMT模型、K-means聚类</td></tr><tr><td style="text-align:center">2019A</td><td style="text-align:center">高压油管的压力控制</td><td style="text-align:center">目标规划模型、微分方程模型、差分法</td></tr><tr><td style="text-align:center">2019B</td><td style="text-align:center">“同心协力”策略研究</td><td style="text-align:center">欧拉刚体旋转定理、模拟退火算法、动力学方程、二阶微分方程</td></tr><tr><td style="text-align:center">==2019C==</td><td style="text-align:center">==机场的出租车问题==</td><td style="text-align:center">==目标优化，排队论，蒙特卡洛模拟==</td></tr><tr><td style="text-align:center">2020A</td><td style="text-align:center">炉温曲线</td><td style="text-align:center">热传导方程、差分法、多目标规划、模拟退火算法</td></tr><tr><td style="text-align:center">2020B</td><td style="text-align:center">穿越沙漠</td><td style="text-align:center">蒙特卡洛模型、动态规划、博弈论、马尔可夫链</td></tr><tr><td style="text-align:center">==2020C==</td><td style="text-align:center">==中小微企业的信贷决策==</td><td style="text-align:center">==Bp神经网络、主成分分析、遗传算法、多目标规划==</td></tr><tr><td style="text-align:center">2021A</td><td style="text-align:center">”FAST“主动反射面的形状调节</td><td style="text-align:center">反射面板调节优化模型、BFGS 算法、蒙特卡洛积分算法</td></tr><tr><td style="text-align:center">2021B</td><td style="text-align:center">乙醇偶合制备C4烯烃</td><td style="text-align:center">多元回归模型、BP神经网络</td></tr><tr><td style="text-align:center">==2021C==</td><td style="text-align:center">==生产企业原材料的订购与运输==</td><td style="text-align:center">==动态权重的贪心算法、动态规划算法、背包规划运输算法、熵权法-TOPSIS模型==</td></tr><tr><td style="text-align:center">2022A</td><td style="text-align:center">波浪能最大输出功率设计</td><td style="text-align:center">多自由度线性系统、多元微分方程、平动非惯性系</td></tr><tr><td style="text-align:center">2022B</td><td style="text-align:center">无人机遂行编队飞行中的纯方位无源定位</td><td style="text-align:center">遍历算法、定位模型、调整方案模型、迭代算法、仿真模拟</td></tr><tr><td style="text-align:center">==2022C==</td><td style="text-align:center">==古代玻璃制品的成分分析与鉴别==</td><td style="text-align:center">==Bp神经网络、聚类算法、回归分析==</td></tr></tbody></table></div><p><img src="https://file.imgcc.cloud/images/2024/08/13/b439af396bb743b46b5d97db8fac10c0.png" alt="屏幕截图 2024 08 13 132959"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/cfc52d983a0c268cdb9b21d24df55afd.png" alt="image"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/b6b8043e2ccd6b280d0672f726772162.png" alt="image"></p><h2 id="二、近年赛题分析"><a href="#二、近年赛题分析" class="headerlink" title="二、近年赛题分析"></a>二、近年赛题分析</h2><h3 id="1、2018年B-智能RGV的动态调度策略"><a href="#1、2018年B-智能RGV的动态调度策略" class="headerlink" title="1、2018年B 智能RGV的动态调度策略"></a>1、2018年B 智能RGV的动态调度策略</h3><p>任务1：RGV动态调度模型和求解算法</p><p>1.1 RGV动态调度模型： 在智能加工系统中，RGV需要根据不同的任务需求，动态调度CNC机床的加工任务。为了提高加工效率和降低系统的空闲时间，可以根据下面的策略进行调度：</p><ul><li>最短等待时间优先：RGV选择离当前位置最近的CNC机床，优先处理等待时间最短的任务。</li><li>先来先服务：RGV按照任务的到达顺序依次处理任务。</li><li>最近机床优先：RGV选择离当前位置最近的CNC机床进行处理。</li></ul><p>1.2 求解算法： 为了优化RGV的调度策略，可以采用下面的算法：</p><ul><li>==贪心算法：==根据当前任务的需求和系统的状态，选择符合策略的最优机床进行处理。</li><li>==动态规划算法：==将RGV的调度问题转化为一个最优化问题，利用动态规划方法求解最优调度策略。</li></ul><p>任务2：RGV调度策略和系统作业效率</p><p>2.1 RGV调度策略： 根据任务1中提到的调度策略，结合实际情况，选择合适的调度策略来调度RGV的工作任务。具体的调度策略可以根据任务需求和系统状态来确定，例如根据离当前位置最近的CNC机床或者根据等待时间最短的任务进行调度。</p><p>2.2 系统作业效率： 将给定的系统参数输入到模型中，根据任务2.1中确定的调度策略，计算系统的作业效率。作业效率可以通过下面的指标进行评估：</p><ul><li>平均等待时间：计算所有物料的等待时间的平均值，评估系统的运行效率。</li><li>加工完成时间：计算所有物料加工完成所需的时间，评估系统的加工效率。</li></ul><h3 id="2、2019C-机场的出租车问题"><a href="#2、2019C-机场的出租车问题" class="headerlink" title="2、2019C 机场的出租车问题"></a>2、2019C 机场的出租车问题</h3><p>(1) 在建立出租车司机选择==决策模型==时，可以考虑以下因素的影响机理：</p><ul><li>乘客数量：根据历史数据和季节性变化，分析不同时间段乘客数量的变化规律，影响司机选择等候还是返回市区拉客的策略。如果乘客数量多，司机更愿意选择等待载客；如果乘客数量少，司机更愿意返回市区拉客。</li><li>蓄车池已有车辆数量：如果蓄车池中已有很多车辆等待载客，司机可能会选择返回市区拉客，避免等待时间过长。而如果蓄车池中车辆较少，司机可能更愿意在蓄车池等候。</li><li>时间成本和空载成本：司机会综合考虑等待载客的时间成本和直接返回市区的空载成本，决定选择哪种策略。</li></ul><p>根据以上因素，可以建立一个决策模型，通过量化各个因素的权重和效益，使司机能够根据实时的乘客数量和蓄车池情况作出决策。</p><p>(2) 收集相关数据后，可以通过统计分析得出该机场出租车司机的选择方案。可以根据不同时间段的乘客数量和蓄车池中车辆数量的统计数据，分析司机选择等待载客还是返回市区拉客的情况。同时，还可以收集出租车运营成本、空载成本和载客收益等数据，进行经济效益分析，验证模型的合理性。</p><p>(3) 对于如何设置“上车点”，管理部门可以考虑以下因素：</p><ul><li>出租车和乘客的安全：应确保上车点的位置合理布置，保证出租车和乘客的安全。</li><li>总的乘车效率最高：根据乘车区的道路情况和乘车需求量，合理设计乘车区的布局，可以设置多个上车点，并根据乘车需求量的变化，调整上车点的数量和位置，以使得总的乘车效率最高。</li></ul><p><img src="C:\Users\28696\Pictures\Screenshots\屏幕截图 2023-07-20 160309.png" alt="屏幕截图 2023-07-20 160309"  /></p><h3 id="3、2020C-中小微企业的信贷决策"><a href="#3、2020C-中小微企业的信贷决策" class="headerlink" title="3、2020C 中小微企业的信贷决策"></a>3、2020C 中小微企业的信贷决策</h3><h4 id="3-1问题一"><a href="#3-1问题一" class="headerlink" title="3.1问题一"></a>3.1问题一</h4><p>​        把目前所能拿到的数据转化一列定量的数据用于评价信贷风险，然后根据这个比例来按进行分配贷款。</p><p>其<strong>大纲解题思路</strong>步骤如下：</p><ol><li>尽可能地构造多的特征（X），以是否违约为Y，构造一个分类模型</li><li>只利用这个分类模型输出的预测概率，如【是否违约_否】的概率，也就把违规预测模型转为了信贷风险模型</li><li>将输出的概率进行归一化，如【是否违约_否】的概率进行归一化，然后按比例分配贷款</li></ol><p>这一题的改进策略有：</p><p>1，调整模型参数（效果微小），可以用启发式算法进行调优，如粒子群算法、遗传算法、模拟退火算法</p><p>2，扩充特征指标（效果中等），以便搜寻更多信息扩展更多指标特征</p><p>3，扩充样本数量（效果卓越），使用或者改进更优秀的采样算法，或者找到更多的训练样本数据</p><h4 id="3-2问题二"><a href="#3-2问题二" class="headerlink" title="3.2问题二"></a>3.2问题二</h4><p>​        在问题1的基础上，对企业的信贷风险进行量化分析，并给出该银行在年度信贷总额为1亿元时对这些企业的信贷策略，预测附件2的是否违约（Y），产生概率用于分配贷款。</p><h4 id="3-3问题三"><a href="#3-3问题三" class="headerlink" title="3.3问题三"></a>3.3问题三</h4><p>​        这里要求给出信贷调整策略，原因是突发因素会对不同行业、不同类别的企业会有不同的影响，例如对互联网行业，新冠病毒疫情是促进的，但是对于旅游业，新冠病毒疫情则导致了其大萧条，可以做一个行业的分类，然后搜集数据进行赋权，有数据可以用熵权法，RSR等算法，而如果没有数据的情况下，可以采用层次分析法进行分析</p><h3 id="4、2021C-生产企业原材料的订购与运输"><a href="#4、2021C-生产企业原材料的订购与运输" class="headerlink" title="4、2021C 生产企业原材料的订购与运输"></a>4、2021C 生产企业原材料的订购与运输</h3><h4 id="4-1问题1"><a href="#4-1问题1" class="headerlink" title="4.1问题1"></a>4.1问题1</h4><p>​        可以采用==聚类算法==对402家供应商进行分析，找出供货特征相似的供应商。可以使用K-means聚类算法或者层次聚类算法。然后根据供货特征的重要性，建立加权指标，通过加权求和确定最重要的50家供应商。</p><h4 id="4-2问题2"><a href="#4-2问题2" class="headerlink" title="4.2问题2"></a>4.2问题2</h4><p>​        可以建立==线性规划模型==，将供货量和订货量作为决策变量，以最小化总采购成本为目标函数，根据每周产能需求、采购单价、供货量和供应商的约束条件，求解最经济的原材料订购方案。同时，可以建立运输规划模型，以最小化总损耗为目标函数，考虑转运商的运输能力和损耗率，确定最少损耗的转运方案。</p><h4 id="4-3问题3"><a href="#4-3问题3" class="headerlink" title="4.3问题3"></a>4.3问题3</h4><p>可以根据企业的要求调整供应商的选择策略，以A类原材料的监控和采购为重点，减少C类原材料的采购量，同时考虑转运商的转运损耗率，以最小化总成本为目标函数，求解新的订购方案和转运方案。</p><h4 id="4-4问题4"><a href="#4-4问题4" class="headerlink" title="4.4问题4"></a>4.4问题4</h4><p>可以建立基于供应商和转运商效能评估的模型，从而确定每周产能的提高潜力。根据供货量和供货的时间限制，求解最大化产能的线性规划模型，得到未来24周的订购和转运方案。</p><h3 id="5、2022C-古代玻璃制品的成分分析与鉴别"><a href="#5、2022C-古代玻璃制品的成分分析与鉴别" class="headerlink" title="5、2022C 古代玻璃制品的成分分析与鉴别"></a>5、2022C 古代玻璃制品的成分分析与鉴别</h3><h4 id="5-1问题1"><a href="#5-1问题1" class="headerlink" title="5.1问题1"></a>5.1问题1</h4><p> 思路：分析玻璃文物的表面风化与其玻璃类型、纹饰和颜色之间的关系，同时结合玻璃的类型，分析风化点的化学成分含量统计规律，预测风化前的化学成分含量。</p><p>模型和算法：</p><ol><li>建立玻璃类型、纹饰和颜色与表面风化之间的关系模型，可以采用==逻辑回归、决策树、支持向量机等分类算法==来建模分析。</li><li>对于有效数据（成分比例累加和介于85%~105%）进行统计分析，计算不同玻璃类型中表面风化化学成分含量的平均值、最大值、最小值等指标，从而得到风化点的化学成分含量统计规律。</li><li>利用==回归算法==根据已有风化点数据，预测其风化前的化学成分含量。</li></ol><h4 id="5-2问题2"><a href="#5-2问题2" class="headerlink" title="5.2问题2"></a>5.2问题2</h4><p>思路：分析高钾玻璃和铅钡玻璃的分类规律，对每个类别选择合适的化学成分进行亚类划分，给出划分方法和结果，并分析分类结果的合理性和敏感性。</p><p>模型和算法：</p><ol><li>可以根据附件表单2中的主要成分所占比例数据，采用聚类算法（如K-Means、DBSCAN等）进行分类，将高钾玻璃和铅钡玻璃分开。</li><li>对于每个类别，可以采用特征选择算法（如相关系数、信息增益等）选取适合的化学成分进行亚类划分。可以使用==聚类算法、决策树==等方法来进行亚类划分。</li><li>分析分类结果的合理性和敏感性，可以采用交叉验证、混淆矩阵等评估指标对分类结果进行验证和分析。</li></ol><h4 id="5-3问题3"><a href="#5-3问题3" class="headerlink" title="5.3问题3"></a>5.3问题3</h4><p>思路：对附件表单3中未知类别玻璃文物的化学成分进行分析，鉴别其所属类型，并对分类结果的敏感性进行分析。</p><p>模型和算法：</p><ol><li>可以利用问题2中建立的分类模型，对附件表单3中未知类别玻璃文物的化学成分进行预测分类，判断其所属类型。</li><li>鉴于分类结果的敏感性，可以采用交叉验证、混淆矩阵等评估指标对分类结果进行验证和分析。</li></ol><h4 id="5-4问题4"><a href="#5-4问题4" class="headerlink" title="5.4问题4"></a>5.4问题4</h4><p>思路：对不同类别的玻璃文物样品，分析其化学成分之间的关联关系，并比较不同类别之间的化学成分关联关系的差异性。</p><p>模型和算法：</p><ol><li>可以利用==相关性分析方法==（如Pearson相关系数、Spearman相关系数等）来分析不同类别玻璃文物样品间化学成分的关联关系。</li><li>可以通过可视化手段（如热力图、散点图等）来展示不同类别玻璃文物样品间的化学成分关联关系，比较其差异性。</li></ol><p>总结： 综合利用分类算法、聚类算法、回归算法和相关性分析等方法，结合问题的具体要求对数据进行分析建模</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MovieLens 1M数据集数据分析</title>
      <link href="/posts/af4a064c.html"/>
      <url>/posts/af4a064c.html</url>
      
        <content type="html"><![CDATA[<h1 id="MovieLens-1M数据集"><a href="#MovieLens-1M数据集" class="headerlink" title="MovieLens 1M数据集"></a>MovieLens 1M数据集</h1><p>这个数据集是电影评分数据：包括电影评分，电影元数据（风格类型，年代）以及关于用户的人口统计学数据（年龄，邮编，性别，职业等）。</p><p>MovieLens 1M数据集评分，用户信息，电影信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Make display smaller</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line">users = pd.read_table(<span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/users.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>, </span><br><span class="line">                      header=<span class="literal">None</span>, names=unames)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 users DataFrame 的前几行以验证数据加载是否成功</span></span><br><span class="line"><span class="built_in">print</span>(users.head())</span><br></pre></td></tr></table></figure><pre><code>   user_id gender  age  occupation    zip0        1      F    1          10  480671        2      M   56          16  700722        3      M   25          15  551173        4      M   45           7  024604        5      M   25          20  55455C:\Users\28696\AppData\Local\Temp\ipykernel_21476\1541965289.py:2: ParserWarning: Falling back to the &#39;python&#39; engine because the &#39;c&#39; engine does not support regex separators (separators &gt; 1 char and different from &#39;\s+&#39; are interpreted as regex); you can avoid this warning by specifying engine=&#39;python&#39;.  users = pd.read_table(&#39;C:/Users/28696/Desktop/人工智能/ml-1m/users.dat&#39;, sep=&#39;::&#39;,</code></pre><p>因为sep=’::’有点像是正则表达式，于是有了上面的错误。解决方法在这个设置engine为python即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">users = pd.read_table(<span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/users.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>, </span><br><span class="line">                      header=<span class="literal">None</span>, names=unames, engine=<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rnames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">ratings = pd.read_table(<span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/ratings.dat&#x27;</span>, sep=<span class="string">&#x27;::&#x27;</span>, </span><br><span class="line">                        header=<span class="literal">None</span>, names=rnames, engine=<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_path = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/movies.dat&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    raw_data = f.read()</span><br><span class="line">    encoding = chardet.detect(raw_data)[<span class="string">&#x27;encoding&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Detected encoding: <span class="subst">&#123;encoding&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Detected encoding: ISO-8859-1</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义列名</span></span><br><span class="line">mnames = [<span class="string">&#x27;movie_id&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用检测到的编码读取数据</span></span><br><span class="line">movies = pd.read_table(file_path, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=mnames, engine=<span class="string">&#x27;python&#x27;</span>, encoding=encoding)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(genre_counts_for_rating_5)</span><br></pre></td></tr></table></figure><pre><code>Action        52187Adventure     26608Animation     10795Children&#39;s    13574Comedy        73530              ...  Romance       32059Sci-Fi        32441Thriller      41408War           23423Western        4965Length: 18, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">genre_counts_for_rating_5.plot(kind=<span class="string">&#x27;bar&#x27;</span>, color=<span class="string">&#x27;skyblue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&#x27;Count of Movies with Rating <span class="subst">&#123;rating&#125;</span>&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Genre&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">f&#x27;Count of Rating <span class="subst">&#123;rating&#125;</span>&#x27;</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>---------------------------------------------------------------------------NameError                                 Traceback (most recent call last)Cell In[64], line 2      1 genre_counts_for_rating_5.plot(kind=&#39;bar&#39;, color=&#39;skyblue&#39;)----&gt; 2 plt.title(f&#39;Count of Movies with Rating &#123;rating&#125;&#39;)      3 plt.xlabel(&#39;Genre&#39;)      4 plt.ylabel(f&#39;Count of Rating &#123;rating&#125;&#39;)NameError: name &#39;plt&#39; is not defined</code></pre><p><img src="https://file.imgcc.cloud/images/2024/08/13/f53d7970651d99b9285260addb04b955.png" alt="output 11 1">    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计所有电影的评分数量</span></span><br><span class="line">rating_counts = data[<span class="string">&#x27;rating&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个评分的占比</span></span><br><span class="line">rating_counts_percentage = (rating_counts / rating_counts.<span class="built_in">sum</span>()) * <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义颜色列表</span></span><br><span class="line">colors = [<span class="string">&#x27;#ff9999&#x27;</span>,<span class="string">&#x27;#66b3ff&#x27;</span>,<span class="string">&#x27;#99ff99&#x27;</span>,<span class="string">&#x27;#ffcc99&#x27;</span>,<span class="string">&#x27;#c2c2f0&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化 - 饼状图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))  <span class="comment"># 设置图形大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 饼状图，包括百分比和数量</span></span><br><span class="line"><span class="comment"># 绘制饼图，包括百分比和数量</span></span><br><span class="line">plt.pie(rating_counts, labels=[<span class="built_in">str</span>(<span class="string">f&#x27;<span class="subst">&#123;rating&#125;</span>: <span class="subst">&#123;count&#125;</span> (<span class="subst">&#123;<span class="built_in">round</span>(percentage, <span class="number">1</span>)&#125;</span>%)&#x27;</span>) <span class="keyword">for</span> rating, count, percentage <span class="keyword">in</span> <span class="built_in">zip</span>(rating_counts.index, rating_counts.values, rating_counts_percentage.values)], autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, startangle=<span class="number">140</span>, colors=colors)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加图表标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;Movie Rating Distribution&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)  <span class="comment"># 保持饼状图为圆形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/60bea2691a95187b49d9b28951b8b6d6.png" alt="output 12 0"><br>​    </p><p>加载前几行验证一下数据加载工作是否顺利</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>user_id</th>      <th>gender</th>      <th>age</th>      <th>occupation</th>      <th>zip</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>F</td>      <td>1</td>      <td>10</td>      <td>48067</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>M</td>      <td>56</td>      <td>16</td>      <td>70072</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>M</td>      <td>25</td>      <td>15</td>      <td>55117</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>M</td>      <td>45</td>      <td>7</td>      <td>02460</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>M</td>      <td>25</td>      <td>20</td>      <td>55455</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ratings[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>user_id</th>      <th>movie_id</th>      <th>rating</th>      <th>timestamp</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>1193</td>      <td>5</td>      <td>978300760</td>    </tr>    <tr>      <th>1</th>      <td>1</td>      <td>661</td>      <td>3</td>      <td>978302109</td>    </tr>    <tr>      <th>2</th>      <td>1</td>      <td>914</td>      <td>3</td>      <td>978301968</td>    </tr>    <tr>      <th>3</th>      <td>1</td>      <td>3408</td>      <td>4</td>      <td>978300275</td>    </tr>    <tr>      <th>4</th>      <td>1</td>      <td>2355</td>      <td>5</td>      <td>978824291</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movies[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>movie_id</th>      <th>title</th>      <th>genres</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>Toy Story (1995)</td>      <td>Animation|Children's|Comedy</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>Jumanji (1995)</td>      <td>Adventure|Children's|Fantasy</td>    </tr>    <tr>      <th>2</th>      <td>3</td>      <td>Grumpier Old Men (1995)</td>      <td>Comedy|Romance</td>    </tr>    <tr>      <th>3</th>      <td>4</td>      <td>Waiting to Exhale (1995)</td>      <td>Comedy|Drama</td>    </tr>    <tr>      <th>4</th>      <td>5</td>      <td>Father of the Bride Part II (1995)</td>      <td>Comedy</td>    </tr>  </tbody></table></div><p>注意，年龄和职业是以编码形式给出的，它们的具体含义请参考改数据集的REAMDE文件。分析散布在三个表中的数据不是一件轻松的事情。假设我们想要根据性别和年龄来计算某部电影的平均得分，如果将所有的数据都合并到一个表中的话，问题就简单多了。我们先用pandas的merge函数将ratings和users合并到一起，然后再将movies也合并进去。pandas会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.merge(pd.merge(ratings, users), movies)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.head()</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th></th>      <th>user_id</th>      <th>movie_id</th>      <th>rating</th>      <th>timestamp</th>      <th>gender</th>      <th>age</th>      <th>occupation</th>      <th>zip</th>      <th>title</th>      <th>genres</th>    </tr>  </thead>  <tbody>    <tr>      <th>0</th>      <td>1</td>      <td>1193</td>      <td>5</td>      <td>978300760</td>      <td>F</td>      <td>1</td>      <td>10</td>      <td>48067</td>      <td>One Flew Over the Cuckoo's Nest (1975)</td>      <td>Drama</td>    </tr>    <tr>      <th>1</th>      <td>2</td>      <td>1193</td>      <td>5</td>      <td>978298413</td>      <td>M</td>      <td>56</td>      <td>16</td>      <td>70072</td>      <td>One Flew Over the Cuckoo's Nest (1975)</td>      <td>Drama</td>    </tr>    <tr>      <th>2</th>      <td>12</td>      <td>1193</td>      <td>4</td>      <td>978220179</td>      <td>M</td>      <td>25</td>      <td>12</td>      <td>32793</td>      <td>One Flew Over the Cuckoo's Nest (1975)</td>      <td>Drama</td>    </tr>    <tr>      <th>3</th>      <td>15</td>      <td>1193</td>      <td>4</td>      <td>978199279</td>      <td>M</td>      <td>25</td>      <td>7</td>      <td>22903</td>      <td>One Flew Over the Cuckoo's Nest (1975)</td>      <td>Drama</td>    </tr>    <tr>      <th>4</th>      <td>17</td>      <td>1193</td>      <td>5</td>      <td>978158471</td>      <td>M</td>      <td>50</td>      <td>1</td>      <td>95350</td>      <td>One Flew Over the Cuckoo's Nest (1975)</td>      <td>Drama</td>    </tr>  </tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><pre><code>user_id                                            1movie_id                                        1193rating                                             5timestamp                                  978300760gender                                             Fage                                                1occupation                                        10zip                                            48067title         One Flew Over the Cuckoo&#39;s Nest (1975)genres                                         DramaName: 0, dtype: object</code></pre><p>列出评分最高的十部电影</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件路径</span></span><br><span class="line">movies_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/movies.dat&#x27;</span></span><br><span class="line">ratings_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/ratings.dat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取电影数据集</span></span><br><span class="line">movies = pd.read_csv(movies_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>], engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取评分数据集</span></span><br><span class="line">ratings = pd.read_csv(ratings_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;userId&#x27;</span>, <span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>], engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并电影和评分数据集，计算每部电影的平均评分</span></span><br><span class="line">movie_ratings = pd.merge(movies, ratings, on=<span class="string">&#x27;movieId&#x27;</span>)</span><br><span class="line">average_ratings = movie_ratings.groupby(<span class="string">&#x27;title&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].mean().reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按平均评分降序排列并选择前10部电影</span></span><br><span class="line">top_movies = average_ratings.sort_values(by=<span class="string">&#x27;rating&#x27;</span>, ascending=<span class="literal">False</span>).head(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示评分最高的十部电影</span></span><br><span class="line"><span class="built_in">print</span>(top_movies)</span><br></pre></td></tr></table></figure><pre><code>                                          title  rating3477                    Ulysses (Ulisse) (1954)     5.02025                               Lured (1947)     5.01203                    Follow the Bitch (1998)     5.0407                    Bittersweet Motel (2000)     5.03087                     Song of Freedom (1936)     5.02453                   One Little Indian (1973)     5.03044                       Smashing Time (1967)     5.02903  Schlafes Bruder (Brother of Sleep) (1995)     5.01297         Gate of Heavenly Peace, The (1995)     5.0249                            Baby, The (1973)     5.0</code></pre><p>根据任意个用户或电影属性对评分数据进行聚合操作了。按性别计算每部电影的平均得分，我们可以使用pivot_table方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean_ratings = data.pivot_table(<span class="string">&#x27;rating&#x27;</span>, index=<span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">                                columns=<span class="string">&#x27;gender&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_ratings[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>gender</th>      <th>F</th>      <th>M</th>    </tr>    <tr>      <th>title</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>$1,000,000 Duck (1971)</th>      <td>3.375000</td>      <td>2.761905</td>    </tr>    <tr>      <th>'Night Mother (1986)</th>      <td>3.388889</td>      <td>3.352941</td>    </tr>    <tr>      <th>'Til There Was You (1997)</th>      <td>2.675676</td>      <td>2.733333</td>    </tr>    <tr>      <th>'burbs, The (1989)</th>      <td>2.793478</td>      <td>2.962085</td>    </tr>    <tr>      <th>...And Justice for All (1979)</th>      <td>3.828571</td>      <td>3.689024</td>    </tr>  </tbody></table></div><p>该操作产生了另一个DataFrame，其内容为电影平均得分，行标为电影名称，列表为性别。现在，我们打算过滤掉评分数据不够250条的电影（这个数字可以自己设定）。为了达到这个目的，我们先对title进行分组，然后利用size()得到一个含有各电影分组大小的Series对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ratings_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>).size()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ratings_by_title[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><pre><code>title$1,000,000 Duck (1971)                37&#39;Night Mother (1986)                  70&#39;Til There Was You (1997)             52&#39;burbs, The (1989)                   303...And Justice for All (1979)        1991-900 (1994)                           210 Things I Hate About You (1999)    700101 Dalmatians (1961)                565101 Dalmatians (1996)                36412 Angry Men (1957)                  616dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">active_titles = ratings_by_title.index[ratings_by_title &gt;= <span class="number">250</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(active_titles)</span><br></pre></td></tr></table></figure><pre><code>Index([&#39;&#39;burbs, The (1989)&#39;, &#39;10 Things I Hate About You (1999)&#39;,       &#39;101 Dalmatians (1961)&#39;, &#39;101 Dalmatians (1996)&#39;, &#39;12 Angry Men (1957)&#39;,       &#39;13th Warrior, The (1999)&#39;, &#39;2 Days in the Valley (1996)&#39;,       &#39;20,000 Leagues Under the Sea (1954)&#39;, &#39;2001: A Space Odyssey (1968)&#39;,       &#39;2010 (1984)&#39;,       ...       &#39;X-Men (2000)&#39;, &#39;Year of Living Dangerously (1982)&#39;,       &#39;Yellow Submarine (1968)&#39;, &#39;You&#39;ve Got Mail (1998)&#39;,       &#39;Young Frankenstein (1974)&#39;, &#39;Young Guns (1988)&#39;,       &#39;Young Guns II (1990)&#39;, &#39;Young Sherlock Holmes (1985)&#39;,       &#39;Zero Effect (1998)&#39;, &#39;eXistenZ (1999)&#39;],      dtype=&#39;object&#39;, name=&#39;title&#39;, length=1216)</code></pre><p>上面的active_titles中的电影，都是评论是大于250条以上的。我们可以用这些标题作为索引，从mean_ratings中选出这些评论大于250条的电影：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mean_ratings = mean_ratings.loc[active_titles]</span><br><span class="line">mean_ratings</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>gender</th>      <th>F</th>      <th>M</th>    </tr>    <tr>      <th>title</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>'burbs, The (1989)</th>      <td>2.793478</td>      <td>2.962085</td>    </tr>    <tr>      <th>10 Things I Hate About You (1999)</th>      <td>3.646552</td>      <td>3.311966</td>    </tr>    <tr>      <th>101 Dalmatians (1961)</th>      <td>3.791444</td>      <td>3.500000</td>    </tr>    <tr>      <th>101 Dalmatians (1996)</th>      <td>3.240000</td>      <td>2.911215</td>    </tr>    <tr>      <th>12 Angry Men (1957)</th>      <td>4.184397</td>      <td>4.328421</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>Young Guns (1988)</th>      <td>3.371795</td>      <td>3.425620</td>    </tr>    <tr>      <th>Young Guns II (1990)</th>      <td>2.934783</td>      <td>2.904025</td>    </tr>    <tr>      <th>Young Sherlock Holmes (1985)</th>      <td>3.514706</td>      <td>3.363344</td>    </tr>    <tr>      <th>Zero Effect (1998)</th>      <td>3.864407</td>      <td>3.723140</td>    </tr>    <tr>      <th>eXistenZ (1999)</th>      <td>3.098592</td>      <td>3.289086</td>    </tr>  </tbody></table><p>1216 rows × 2 columns</p></div><p>想要查看女性观众喜欢的电影，可以按F列进行降序操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_female_ratings = mean_ratings.sort_values(by=<span class="string">&#x27;F&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">top_female_ratings[:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><div><style scoped>    .dataframe tbody tr th:only-of-type {        vertical-align: middle;    }    .dataframe tbody tr th {        vertical-align: top;    }    .dataframe thead th {        text-align: right;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>gender</th>      <th>F</th>      <th>M</th>    </tr>    <tr>      <th>title</th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>Close Shave, A (1995)</th>      <td>4.644444</td>      <td>4.473795</td>    </tr>    <tr>      <th>Wrong Trousers, The (1993)</th>      <td>4.588235</td>      <td>4.478261</td>    </tr>    <tr>      <th>Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)</th>      <td>4.572650</td>      <td>4.464589</td>    </tr>    <tr>      <th>Wallace &amp; Gromit: The Best of Aardman Animation (1996)</th>      <td>4.563107</td>      <td>4.385075</td>    </tr>    <tr>      <th>Schindler's List (1993)</th>      <td>4.562602</td>      <td>4.491415</td>    </tr>    <tr>      <th>Shawshank Redemption, The (1994)</th>      <td>4.539075</td>      <td>4.560625</td>    </tr>    <tr>      <th>Grand Day Out, A (1992)</th>      <td>4.537879</td>      <td>4.293255</td>    </tr>    <tr>      <th>To Kill a Mockingbird (1962)</th>      <td>4.536667</td>      <td>4.372611</td>    </tr>    <tr>      <th>Creature Comforts (1990)</th>      <td>4.513889</td>      <td>4.272277</td>    </tr>    <tr>      <th>Usual Suspects, The (1995)</th>      <td>4.513317</td>      <td>4.518248</td>    </tr>  </tbody></table></div><p>统计喜剧类型电影的男女人数分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件路径</span></span><br><span class="line">movies_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/movies.dat&#x27;</span></span><br><span class="line">ratings_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/ratings.dat&#x27;</span></span><br><span class="line">users_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/users.dat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取评分数据集，指定分隔符为::，编码为ISO-8859-1</span></span><br><span class="line">rnames = [<span class="string">&#x27;userId&#x27;</span>, <span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">ratings = pd.read_csv(ratings_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=rnames, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取用户数据集，指定分隔符为::，编码为ISO-8859-1</span></span><br><span class="line">unames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line">users = pd.read_csv(users_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=unames, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取电影数据集，指定分隔符为::，编码为ISO-8859-1</span></span><br><span class="line">movies = pd.read_csv(movies_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>], engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出类型为喜剧的电影</span></span><br><span class="line">comedy_movies = movies[movies[<span class="string">&#x27;genres&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;comedy&#x27;</span>, na=<span class="literal">False</span>, <span class="keyword">case</span>=<span class="literal">False</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据喜剧电影的ID筛选出评分数据</span></span><br><span class="line">comedy_ratings = ratings[ratings[<span class="string">&#x27;movieId&#x27;</span>].isin(comedy_movies[<span class="string">&#x27;movieId&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并用户数据和喜剧电影评分数据，确保使用正确的列名</span></span><br><span class="line">comedy_ratings_with_users = pd.merge(comedy_ratings, users, left_on=<span class="string">&#x27;userId&#x27;</span>, right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计观看喜剧电影的用户性别分布</span></span><br><span class="line">gender_distribution = comedy_ratings_with_users[<span class="string">&#x27;gender&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化性别分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))  <span class="comment"># 设置图表大小</span></span><br><span class="line">bar_colors = [<span class="string">&#x27;#1f77b4&#x27;</span>, <span class="string">&#x27;#ff7f0e&#x27;</span>]  <span class="comment"># 设置柱状图的颜色</span></span><br><span class="line">plt.bar(gender_distribution.index, gender_distribution.values, color=bar_colors)</span><br><span class="line">plt.title(<span class="string">&#x27;Gender Distribution of Users Rating Comedy Movies&#x27;</span>, fontsize=<span class="number">16</span>)  <span class="comment"># 设置标题和字体大小</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Gender&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置x轴标题和字体大小</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Number of Users&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置y轴标题和字体大小</span></span><br><span class="line">plt.xticks(gender_distribution.index, [<span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>], rotation=<span class="number">0</span>)  <span class="comment"># 设置x轴标签并防止旋转</span></span><br><span class="line">plt.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.7</span>)  <span class="comment"># 添加y轴网格线，设置样式和透明度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.tight_layout()  <span class="comment"># 自动调整子图参数，使之填充整个图表区域</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/a8db55b5f0e83a814ecf21b665182ba4.png" alt="output 36 0"><br>​    </p><p>统计观看喜剧电影的用户年龄分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计观看喜剧电影的用户年龄分布</span></span><br><span class="line"><span class="comment"># 由于年龄数据是离散的，我们可以直接计数</span></span><br><span class="line">age_distribution = comedy_ratings_with_users[<span class="string">&#x27;age&#x27;</span>].value_counts().sort_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化年龄分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))  <span class="comment"># 设置图表大小</span></span><br><span class="line">plt.bar(age_distribution.index, age_distribution.values, color=<span class="string">&#x27;skyblue&#x27;</span>)  <span class="comment"># 使用单一颜色</span></span><br><span class="line">plt.title(<span class="string">&#x27;Age Distribution of Users Rating Comedy Movies&#x27;</span>, fontsize=<span class="number">16</span>)  <span class="comment"># 设置标题和字体大小</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置x轴标题和字体大小</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Number of Users&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置y轴标题和字体大小</span></span><br><span class="line">plt.xticks(age_distribution.index, age_distribution.index)  <span class="comment"># 设置x轴标签</span></span><br><span class="line">plt.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.7</span>)  <span class="comment"># 添加y轴网格线，设置样式和透明度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.tight_layout()  <span class="comment"># 自动调整子图参数，使之填充整个图表区域</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/8fd311ae43f6ab7c6945096f473c272e.png" alt="output 38 0"><br>​    </p><p>统计观看喜剧类型电影的25岁用户的职业分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件路径</span></span><br><span class="line">movies_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/movies.dat&#x27;</span></span><br><span class="line">ratings_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/ratings.dat&#x27;</span></span><br><span class="line">users_file = <span class="string">&#x27;C:/Users/28696/Desktop/人工智能/ml-1m/users.dat&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集</span></span><br><span class="line">rnames = [<span class="string">&#x27;userId&#x27;</span>, <span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;rating&#x27;</span>, <span class="string">&#x27;timestamp&#x27;</span>]</span><br><span class="line">ratings = pd.read_csv(ratings_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=rnames, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">unames = [<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;gender&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;occupation&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>]</span><br><span class="line">users = pd.read_csv(users_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=unames, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">movies = pd.read_csv(movies_file, sep=<span class="string">&#x27;::&#x27;</span>, header=<span class="literal">None</span>, names=[<span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;genres&#x27;</span>], engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;ISO-8859-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出类型为喜剧的电影</span></span><br><span class="line">comedy_movies = movies[movies[<span class="string">&#x27;genres&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;comedy&#x27;</span>, na=<span class="literal">False</span>, <span class="keyword">case</span>=<span class="literal">False</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据喜剧电影的ID筛选出评分数据</span></span><br><span class="line">comedy_ratings = ratings[ratings[<span class="string">&#x27;movieId&#x27;</span>].isin(comedy_movies[<span class="string">&#x27;movieId&#x27;</span>])]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并用户数据和喜剧电影评分数据</span></span><br><span class="line">comedy_ratings_with_users = pd.merge(comedy_ratings, users, left_on=<span class="string">&#x27;userId&#x27;</span>, right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出25岁用户观看的喜剧电影评分</span></span><br><span class="line">age_25_comedy_ratings = comedy_ratings_with_users[(comedy_ratings_with_users[<span class="string">&#x27;age&#x27;</span>] == <span class="number">25</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计25岁用户的职业分布</span></span><br><span class="line">occupation_distribution = age_25_comedy_ratings[<span class="string">&#x27;occupation&#x27;</span>].value_counts()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化职业分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))  <span class="comment"># 设置图表大小</span></span><br><span class="line">plt.bar(occupation_distribution.index, occupation_distribution.values, color=<span class="string">&#x27;skyblue&#x27;</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>, width=<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Occupation Distribution of 25-year-olds Rating Comedy Movies&#x27;</span>, fontsize=<span class="number">16</span>)  <span class="comment"># 设置标题和字体大小</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;Occupation&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置x轴标题和字体大小</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Number of Users&#x27;</span>, fontsize=<span class="number">12</span>)  <span class="comment"># 设置y轴标题和字体大小</span></span><br><span class="line">plt.xticks(occupation_distribution.index, rotation=<span class="number">45</span>)  <span class="comment"># 旋转x轴标签，使其更加清晰</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加网格线，提高可读性</span></span><br><span class="line">plt.grid(axis=<span class="string">&#x27;y&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动调整子图参数，使之填充整个图表区域</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/1c818ef0e33400f1c9f8f881167085af.png" alt="output 40 0"><br>​    </p><p>1、年龄分组：使用 pandas.cut 函数将 users 数据集中的用户年龄分为不同的组。</p><p>2、年龄段评分统计：使用 ratings 数据集，按照用户年龄分组统计每个年龄段的用户数量和平均评分。</p><p>3、被评价次数最多的电影：使用 ratings 数据集找出被评价次数最多的50部电影。</p><p>4、年龄段评分差异：对这些电影在不同年龄段的平均评分进行比较。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 users 和 ratings 是已经加载的用户和评分数据集</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用pandas.cut函数将用户年龄分组</span></span><br><span class="line">labels = [<span class="string">&#x27;0-9&#x27;</span>, <span class="string">&#x27;10-19&#x27;</span>, <span class="string">&#x27;20-29&#x27;</span>, <span class="string">&#x27;30-39&#x27;</span>, <span class="string">&#x27;40-49&#x27;</span>, <span class="string">&#x27;50-59&#x27;</span>, <span class="string">&#x27;60-69&#x27;</span>, <span class="string">&#x27;70-79&#x27;</span>]</span><br><span class="line">users[<span class="string">&#x27;age_group&#x27;</span>] = pd.cut(users.age, bins=<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">81</span>, <span class="number">10</span>), labels=labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并用户数据和评分数据集时使用正确的列名</span></span><br><span class="line">ratings_with_users = pd.merge(ratings, users[[<span class="string">&#x27;user_id&#x27;</span>, <span class="string">&#x27;age_group&#x27;</span>]], left_on=<span class="string">&#x27;userId&#x27;</span>, right_on=<span class="string">&#x27;user_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个年龄段用户评分人数和打分偏好</span></span><br><span class="line">age_rating_stats = ratings_with_users.groupby(<span class="string">&#x27;age_group&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].agg([np.size, np.mean])</span><br><span class="line"><span class="built_in">print</span>(age_rating_stats)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找被评价过最多次的50部电影</span></span><br><span class="line">top_rated_movies = ratings_with_users[<span class="string">&#x27;movieId&#x27;</span>].value_counts().head(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看这些电影在不同年龄段之间的打分差异</span></span><br><span class="line">rating_diff_by_age = ratings_with_users[ratings_with_users[<span class="string">&#x27;movieId&#x27;</span>].isin(top_rated_movies.index)].groupby([<span class="string">&#x27;age_group&#x27;</span>, <span class="string">&#x27;movieId&#x27;</span>])[<span class="string">&#x27;rating&#x27;</span>].mean().reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用unstack函数将数据转换为一个表格</span></span><br><span class="line">rating_diff_unstacked = rating_diff_by_age.pivot_table(index=<span class="string">&#x27;movieId&#x27;</span>, columns=<span class="string">&#x27;age_group&#x27;</span>, values=<span class="string">&#x27;rating&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(rating_diff_unstacked.head(<span class="number">50</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化某部电影在不同年龄段的评分分布</span></span><br><span class="line">example_movie_id = ratings_with_users[ratings_with_users[<span class="string">&#x27;movieId&#x27;</span>].isin(top_rated_movies.index)][<span class="string">&#x27;movieId&#x27;</span>].iloc[<span class="number">0</span>]</span><br><span class="line">example_movie_ratings = rating_diff_by_age[rating_diff_by_age[<span class="string">&#x27;movieId&#x27;</span>] == example_movie_id]</span><br><span class="line">plt.bar(example_movie_ratings[<span class="string">&#x27;age_group&#x27;</span>], example_movie_ratings[<span class="string">&#x27;rating&#x27;</span>], color=<span class="string">&#x27;skyblue&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&quot;Average Rating of Movie <span class="subst">&#123;example_movie_id&#125;</span> by Age Group&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Average Rating&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age Group&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><pre><code>             size      meanage_group                  0-9         27211  3.54952010-19      183536  3.50757320-29      395556  3.54523530-39      199003  3.61816240-49      156123  3.67355950-59       38780  3.76663260-69           0       NaN70-79           0       NaNage_group       0-9     10-19     20-29     30-39     40-49     50-59movieId                                                              1          3.919643  4.017857  4.201266  4.302600  4.099602  3.88679234         3.325843  3.609929  3.957813  4.023684  4.007067  3.94805250         4.424242  4.680798  4.552430  4.390879  4.291866  4.431373110        4.192982  4.406250  4.254292  4.152318  4.108635  3.969388260        4.267327  4.427046  4.572695  4.354633  4.421397  4.250000...             ...       ...       ...       ...       ...       ...2916       3.441176  3.605978  3.651054  3.737500  3.820069  3.7058822987       3.888889  3.716578  3.638607  3.685552  3.695817  3.6666672997       4.090909  4.202083  4.091703  4.156171  4.064407  4.1494253175       3.739130  3.656357  3.764253  3.830380  3.815094  3.8644073578       4.203390  4.231441  4.084291  3.981651  4.147186  3.878788[50 rows x 6 columns]</code></pre><p><img src="https://file.imgcc.cloud/images/2024/08/13/e72455dc7d1f44e8391e8d1ecfb0fdb9.png" alt="output 45 1"></p><h1 id="1-Measuring-Rating-Disagreement（计算评分分歧）"><a href="#1-Measuring-Rating-Disagreement（计算评分分歧）" class="headerlink" title="1 Measuring Rating Disagreement（计算评分分歧）"></a>1 Measuring Rating Disagreement（计算评分分歧）</h1><p>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给mean_ratings加上一个用于存放平均得分之差的列，并对其进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean_ratings[<span class="string">&#x27;diff&#x27;</span>] = mean_ratings[<span class="string">&#x27;M&#x27;</span>] - mean_ratings[<span class="string">&#x27;F&#x27;</span>]</span><br></pre></td></tr></table></figure><p>按‘diff’排序即可得到分歧最大且女性观众更喜欢的电影：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sorted_by_diff = mean_ratings.sort_values(by=<span class="string">&#x27;diff&#x27;</span>)</span><br><span class="line">sorted_by_diff[:<span class="number">15</span>]</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>gender</th>      <th>F</th>      <th>M</th>      <th>diff</th>    </tr>    <tr>      <th>title</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>Dirty Dancing (1987)</th>      <td>3.790378</td>      <td>2.959596</td>      <td>-0.830782</td>    </tr>    <tr>      <th>Jumpin' Jack Flash (1986)</th>      <td>3.254717</td>      <td>2.578358</td>      <td>-0.676359</td>    </tr>    <tr>      <th>Grease (1978)</th>      <td>3.975265</td>      <td>3.367041</td>      <td>-0.608224</td>    </tr>    <tr>      <th>Little Women (1994)</th>      <td>3.870588</td>      <td>3.321739</td>      <td>-0.548849</td>    </tr>    <tr>      <th>Steel Magnolias (1989)</th>      <td>3.901734</td>      <td>3.365957</td>      <td>-0.535777</td>    </tr>    <tr>      <th>...</th>      <td>...</td>      <td>...</td>      <td>...</td>    </tr>    <tr>      <th>French Kiss (1995)</th>      <td>3.535714</td>      <td>3.056962</td>      <td>-0.478752</td>    </tr>    <tr>      <th>Little Shop of Horrors, The (1960)</th>      <td>3.650000</td>      <td>3.179688</td>      <td>-0.470312</td>    </tr>    <tr>      <th>Guys and Dolls (1955)</th>      <td>4.051724</td>      <td>3.583333</td>      <td>-0.468391</td>    </tr>    <tr>      <th>Mary Poppins (1964)</th>      <td>4.197740</td>      <td>3.730594</td>      <td>-0.467147</td>    </tr>    <tr>      <th>Patch Adams (1998)</th>      <td>3.473282</td>      <td>3.008746</td>      <td>-0.464536</td>    </tr>  </tbody></table><p>15 rows × 3 columns</p></div><p>对行进行反序操作，并取出前15行，得到的则是男性更喜欢，而女性评价较低的电影：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reverse order of rows, take first 10 rows</span></span><br><span class="line">sorted_by_diff[::-<span class="number">1</span>][:<span class="number">10</span>]</span><br></pre></td></tr></table></figure><div><style>    .dataframe thead tr:only-child th {        text-align: right;    }    .dataframe thead th {        text-align: left;    }    .dataframe tbody tr th {        vertical-align: top;    }</style><table border="1" class="dataframe">  <thead>    <tr style="text-align: right;">      <th>gender</th>      <th>F</th>      <th>M</th>      <th>diff</th>    </tr>    <tr>      <th>title</th>      <th></th>      <th></th>      <th></th>    </tr>  </thead>  <tbody>    <tr>      <th>Good, The Bad and The Ugly, The (1966)</th>      <td>3.494949</td>      <td>4.221300</td>      <td>0.726351</td>    </tr>    <tr>      <th>Kentucky Fried Movie, The (1977)</th>      <td>2.878788</td>      <td>3.555147</td>      <td>0.676359</td>    </tr>    <tr>      <th>Dumb &amp; Dumber (1994)</th>      <td>2.697987</td>      <td>3.336595</td>      <td>0.638608</td>    </tr>    <tr>      <th>Longest Day, The (1962)</th>      <td>3.411765</td>      <td>4.031447</td>      <td>0.619682</td>    </tr>    <tr>      <th>Cable Guy, The (1996)</th>      <td>2.250000</td>      <td>2.863787</td>      <td>0.613787</td>    </tr>    <tr>      <th>Evil Dead II (Dead By Dawn) (1987)</th>      <td>3.297297</td>      <td>3.909283</td>      <td>0.611985</td>    </tr>    <tr>      <th>Hidden, The (1987)</th>      <td>3.137931</td>      <td>3.745098</td>      <td>0.607167</td>    </tr>    <tr>      <th>Rocky III (1982)</th>      <td>2.361702</td>      <td>2.943503</td>      <td>0.581801</td>    </tr>    <tr>      <th>Caddyshack (1980)</th>      <td>3.396135</td>      <td>3.969737</td>      <td>0.573602</td>    </tr>    <tr>      <th>For a Few Dollars More (1965)</th>      <td>3.409091</td>      <td>3.953795</td>      <td>0.544704</td>    </tr>  </tbody></table></div><p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据电影名称分组的得分数据的标准差</span></span><br><span class="line">rating_std_by_title = data.groupby(<span class="string">&#x27;title&#x27;</span>)[<span class="string">&#x27;rating&#x27;</span>].std()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据active_titles进行过滤</span></span><br><span class="line">rating_std_by_title = rating_std_by_title.loc[active_titles]</span><br></pre></td></tr></table></figure><p>不同性别间争议最大的电影</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件路径</span></span><br><span class="line">movies_file = <span class="string">&quot;C:\\Users\\28696\\Desktop\\人工智能\\ml-1m\\movies.dat&quot;</span></span><br><span class="line">ratings_file = <span class="string">&quot;C:\\Users\\28696\\Desktop\\人工智能\\ml-1m\\ratings.dat&quot;</span></span><br><span class="line">users_file = <span class="string">&quot;C:\\Users\\28696\\Desktop\\人工智能\\ml-1m\\users.dat&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集时指定分隔符、列名和编码</span></span><br><span class="line"><span class="comment"># 此处省略了加载数据集的代码，假设数据集已正确加载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并数据集的代码保持不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置索引并保留 movieId 和 title 列</span></span><br><span class="line">lens.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建透视表，使用 &#x27;rating&#x27; 和 &#x27;gender&#x27; 列</span></span><br><span class="line">pivoted = lens.pivot_table(index=[<span class="string">&#x27;movieId&#x27;</span>, <span class="string">&#x27;title&#x27;</span>], columns=<span class="string">&#x27;gender&#x27;</span>, values=<span class="string">&#x27;rating&#x27;</span>, fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算男女评分差异</span></span><br><span class="line">pivoted[<span class="string">&#x27;diff&#x27;</span>] = pivoted[<span class="string">&#x27;M&#x27;</span>] - pivoted[<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出评分差异最大的50部电影的索引</span></span><br><span class="line">most_50 = pivoted[<span class="string">&#x27;diff&#x27;</span>].<span class="built_in">abs</span>().sort_values(ascending=<span class="literal">False</span>).index[:<span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制条形图，设置颜色为浅蓝色</span></span><br><span class="line">disagreements = pivoted.loc[most_50, <span class="string">&#x27;diff&#x27;</span>]</span><br><span class="line">light_blue_color = <span class="string">&#x27;#ADD8E6&#x27;</span>  <span class="comment"># 浅蓝色颜色代码</span></span><br><span class="line">disagreements.sort_values().plot(kind=<span class="string">&#x27;barh&#x27;</span>, figsize=(<span class="number">12</span>, <span class="number">15</span>), color=light_blue_color)</span><br><span class="line">plt.title(<span class="string">&#x27;Male vs. Female Avg. Ratings\n(Difference &gt; 0 = Favored by Men)&#x27;</span>, fontsize=<span class="number">16</span>, fontweight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Movie&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Average Rating Difference&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动调整子图参数，使之填充整个图表区域</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>​<br><img src="https://file.imgcc.cloud/images/2024/08/13/ad930fbe6b40444b702caeb0faf67bd2.png" alt="output 56 0"><br>​    </p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RBM模型研读笔记</title>
      <link href="/posts/cf0901bc.html"/>
      <url>/posts/cf0901bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="论文笔记：Restricted-Boltzmann-Machines-for-Collaborative-Filtering"><a href="#论文笔记：Restricted-Boltzmann-Machines-for-Collaborative-Filtering" class="headerlink" title="论文笔记：Restricted Boltzmann Machines for Collaborative Filtering"></a>论文笔记：Restricted Boltzmann Machines for Collaborative Filtering</h2><p><strong>摘要</strong></p><p>目前存在的大多数协同过滤算法都不能解决大量数据集对应的矩阵运算，本文中展示了两层的无向图模型，即RBM，可以用来建模表格数据，比如用户评级。我们给出了高效的算法，证明了它在很大的数据集上可以运行。同时，还证明了它比SVD的性能略好。当RBM和SVD组合时，可以获得6%的性能提升。</p><p><strong>绪论</strong></p><p>协同过滤的一个常用方法是矩阵分解。假如用N<em>M的矩阵来表示N名用户评价M个电影，那么N</em>M矩阵可以写为N<em>C的矩阵和C</em>M的矩阵的乘积，其中前者是用户矩阵，后者是电影矩阵，C是主题的个数。</p><p>通常来说，这一过程通过奇异值分解(SVD)来完成。但大规模的数据集通常面临着矩阵过于稀疏的问题，这使得奇异值分解变得很难进行。本文中提出了RBM的解法。而且通过CD-k采样，可以使RBM算法精确又高效。</p><p><strong>受限玻尔兹曼机(RBM)</strong></p><p>我们要训练的是一个RBM。假如所有N个用户都评价了M个电影，那么就可以把每个用户看作一个单独的训练样本，玻尔兹曼机有M个可视节点和若干隐藏节点。现在的问题是矩阵是稀疏的，那么我们选择不去填充这个缺失项，我们纯粹是忽略它们。</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/d73919d7ffe0a91d46272d49ceafa572.png" alt="image"></p><p>依然是用每个用户的评分记录作为一个训练样本，但是注意，对于每一个用户，我们只关注他有评分的那些项。无论是前向还是反向传播或者训练，我们都只关注建立了连接的这些节点。</p><p><strong>2.1 模型建立</strong></p><p>根据前面的表述，V是一个K*m的矩阵，它以二元的形式表征了用户对电影的评分情况。首先把V的每一列建模为条件多项式分布(其实也就是对每一个电影的评分建模)</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/6e8e83a658f62f4f2a22a9505d7b3069.png" alt="image"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/c26e218cd329141983b6b31b1b975678.png" alt="image"></p><p>然后把隐藏节点建模为条件伯努利分布(根据文中的表述，j个隐藏节点应该代表了j个主题)</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/3242e8a714dd2906dc5adfdbbd84fda2.png" alt="image"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/3a4d242266569a19d9689dea1cc3aab5.png" alt="image">是逻辑斯蒂函数<img src="https://file.imgcc.cloud/images/2024/08/13/b53cce46ac5c67c5834fefa0506c02d3.png" alt="image">是电影i的特征j和等级k之间的对称交互参数，<img src="https://file.imgcc.cloud/images/2024/08/13/44ad57ba383da72813b6e0dc7752db31.png" alt="image">表示电影i在分数k上的偏倚，而<img src="https://file.imgcc.cloud/images/2024/08/13/4efb1d1a1a7bf825b3ea9bdb7101529a.png" alt="image">是特征j的偏倚。<img src="https://file.imgcc.cloud/images/2024/08/13/e1ee2c7dcea7995d208c2271e160ecf1.png" alt="image">可以被初始化为评分的i平均值。</p><p>下面，根据RBM的相关知识，可以写出概率函数 </p><p><img src="https://file.imgcc.cloud/images/2024/08/13/477e8cc8e275996ee4450f082b9e2880.png" alt="image"></p><p>以及能量函数</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/2a69ff9d8cef6d54a3699f15bdf15477.png" alt="image"></p><p>Z这一项，论文里说这个是归一化因子。</p><p>这里我觉得需要注意的一点是，标准的RBM中，每一个可视节点对应的是一个数，而这里对应的是一个K维的向量。所以对应的，W是一个i<em>j</em>k的矩阵，是一个m<em>k的矩阵，是一个1</em>j的向量，这是因为隐藏节点是一维的；和虽然都叫b，但是并不是同一个东西。</p><p><strong>2.2 训练</strong></p><p>根据RBM的公式，很容易可以得到</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/ec85f88383922533e06d01d4ebad2c40.png" alt="image"></p><p>其中，data和model分别代表了数据和模型驱动下的两个值的内积。那么我们要做的当然就是让内积最小化，这也有点类似于极大似然估计。这边使用了==对比散度方法==</p><hr><p>本文的方法，是在得到RBM模型之后，用用户的电影评分向量作为输入向量，然后用RBM reconstruct用户的输入向量，包括那些missing input（表示用户没看过的电影）。此时，这些missing input的值就是表示了用户对这个电影的喜好程度。电影有k个评分，RBM reconstruct 对这k个值（所对应的节点）都有输出。选择用户对这个电影的预测评分就有两种方法：</p><ol><li>选择k个节点中RBM输出权值最大的那个节点作为用户对当前电影的评分；</li><li>对这k个节点的权重加权平均，平均值离k个数字哪个最近，就是评分是多少。在实践中，这两种方法都可以尝试一下。</li></ol><hr><p>  我们输入用户目前已经有的评分，可以算出隐藏节点，然后再由隐藏节点反向可以算出全部的可视节点，也就是填补了那些缺失的评分。</p><p><strong>3.条件RBM</strong></p><p>这里提到了一个问题，就是在上面训练的时候，是直接忽略了没看过的那些电影，而我们没有输入的节点会确确实实地影响到输入值。在数据中，有些用户可能看过电影，但是没有评分数据，因为没有评分或者评分被弄丢了，这种情况是值得注意的。</p><p>文章中给出了一个解决的思路Conditional RBM，它可以加入一些外部数据的影响，然而这一章里并没有用这个思路。这一章里，对于那些看过但是没有评分的条例，用电影的base rate作为输入值进行了训练，并获得了不错的结果。</p><p><strong>4.</strong> <strong>条件分解RBM</strong></p><p>上面的矩阵还有一个问题，就是W矩阵维度过大。过大的矩阵一方面会导致计算困难，另一方面会很容易产生严重的过拟合。为了解决这个问题，矩阵分解可以上场</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/d91c3b71eaa472450c8ec17060d8d008.png" alt="image"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/901b7eaceb68597252703855c0d6e462.png" alt="image"></p><p>分解后的矩阵参数量大大减小，速度也快的多。</p><p><strong>5.</strong> <strong>实验结果</strong></p><p><strong>参数设置</strong></p><p>隐特征数：100</p><p>5的降维矩阵中隐特征数500，降维之后C=30</p><p>Batch-size：1000</p><p>迭代次数：40-50</p><p>学习率：0.01</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/dc2d8b4d85f71cfbc809513377ff3d58.png" alt="image"></p><p>没有给出baseline，但应该是很好的。</p><p><strong>6.奇异值分解</strong></p><p>奇异值分解的原理，不再赘述。</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/f8bf17721248ff9a8476a41c6828452b.png" alt="image"></p><p>可以看出，RBM的效果更好，不过没有好太多。</p><p>在实验中，SVD经过了精心的调参，但是RBM还有很多参数可以优化，比如学习率，batch-size等。所以RBM有着更多的潜力。另外，SVD和RBM的错误很不一样，所以对它们进行模型融合也会获得不错的结果。</p><p>感觉怎么说呢</p><p>1.学习自动编码器：感觉就是把RBM变成了自编码器，从而把随机隐藏向量变成了实数向量。</p><p>2.学习更深的生成模型</p><p><strong>7.我的思考</strong></p><p>只看懂了一个大概的意思。RBM在这里我觉得是类似于自编码器的存在，提取隐藏特征，给出其他的矩阵评分。这巧妙地利用了电影与电影之间的关系，使得预测变得简洁高效。其实感觉挺微妙的，当时看其他论文的时候脑子里突然就有这个想法，历史数据稀疏性、长短时记忆、冷启动（粗粒度个性化推荐、隐式信息反馈）时间性预测、多态相互融合、标签化之间关系连接做出推荐信息通路，最后如何汇总组合…… 感觉不止这些，最近看的越多论文 潜意识感觉好多东西中间有个东西在连接着它们 隐隐在往上推在寻找一个最优的平衡点……</p><p>顺便，讲得比较好的几个RBM的原理在这里</p><p><a href="https://blog.csdn.net/Yt7589/article/details/52487505">https://blog.csdn.net/Yt7589/article/details/52487505</a></p><p><a href="https://blog.csdn.net/peghoty/article/details/19168937">https://blog.csdn.net/peghoty/article/details/19168937</a></p><p>大体有了感性的认识。希望以后看了新的论文会有一些更深入的思考。</p><p>技术总结：</p><p>1.对矩阵的降维。第五部分中讲解了如何通过降维来大大提升运行速度，降维是一个非常万能的方法，可以留意一下。</p><p>2.加入“看过但是未评分的记录”，充分利用信息优化结果。</p><p>3.利用diversity的特性来做模型融合。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NCF论文研读笔记</title>
      <link href="/posts/153bfe0a.html"/>
      <url>/posts/153bfe0a.html</url>
      
        <content type="html"><![CDATA[<h3 id="NCF论文研读笔记"><a href="#NCF论文研读笔记" class="headerlink" title="NCF论文研读笔记"></a>NCF论文研读笔记</h3><p>随着近些年来深度学习的发展，在推荐系统方面，越来越多的推荐模型是基于神经网络来解决推荐问题，但这些模型主要使用它来模拟辅助信息，例如项目的文本描述和音乐的声学特征。而在对协同过滤的关键因素——用户和项目特征之间的交互进行建模时，大部分工作仍然采用矩阵分解（matrix factorization），并对用户和项目的潜在特征应用内积(inner product)。 NCF模型与传统的矩阵分解的不同在于，NCF对分解之后获得的隐向量不再是简单地进行内积操作，而是考虑更为复杂的内积形式，并利用多层感知机，对用户-物品交互信息进行深入地学习，从而获取更好的结果。</p><h4 id="1-MF模型"><a href="#1-MF模型" class="headerlink" title="1. MF模型"></a>1. MF模型</h4><p>MF模型（矩阵分解模型）的实现思路是通过对由n个用户和m个物品组成的用户-物品评分矩阵进行分解，将整体评分矩阵分解为两个矩阵的乘积，其中一个矩阵的大小为n<em>k，另一个矩阵的大小为k</em>m，这两个矩阵中的维度k表示潜在空间维度。接着对于第i个用户对第j个物品的喜爱程度评估问题，可以利用第一个矩阵中的第i个用户的k维向量与第二个矩阵中第j个物品的k维向量进行内积，计算得到具体的喜爱程度： </p><p><img src="https://file.imgcc.cloud/images/2024/08/13/4356cfef9f754f4073d67038a40490fe.png" alt="image"></p><p>其中，向量<strong>p</strong>u表示用户u的隐向量，向量<strong>q</strong>i表示物品i的隐向量。然而这种方式由于仅仅是简单地进行线性内积操作，因此，存在着一定的问题，比如，现假设存在用户u1，u2，u3，其中u1与u2具有较高的相似度，在隐向量空间中表现为向量间夹角较小，而u1与u3的相似度比较低，在隐向量空间中表现维向量间夹角较大，这时，如果出现一位新的用户u4，且u4与其他三个用户的相似度从大到小排序为u1、u3、u2，那么就有可能存现如下图所示的情况：</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/384a0eb9c624cc376ba9fd7455594eaa.png" alt="image"></p><p>(a)是user-item交互矩阵，1(b)是用户的隐式空间，论文中强调了两点来理解这张图片：</p><p> 1）MF将user和item分布到同样的隐式空间中，那么两个用户之间的相似性也可以用二者在隐式空间中的向量夹角来确定。</p><p> 2）使用Jaccard系数（用户交互项目集 交/并）来作为真实的用户相似性。</p><p>图中，<strong>p</strong>1、<strong>p</strong>2、<strong>p</strong>3向量是原先已 经确定的，而在考虑引入新用户u4时，无论u4对应的隐向量位于哪一根虚线，都无法满足u4和u3之间的相似度大于u4和u2之间的相似度。而一种解决的方案是将维度k增大，即利用更高维度的空间来表示隐向量，但是这种做法可能会对模型的泛化产生不利影响（例如，过度拟合数据），尤其是在稀疏设置中，因此，本篇论文针对这一缺点，对模型的MF部分进行了改进，提出一种基于NCF通用结构的GMF模型。</p><h4 id="2-模型通用结构"><a href="#2-模型通用结构" class="headerlink" title="2.模型通用结构"></a>2.模型通用结构</h4><p><img src="https://file.imgcc.cloud/images/2024/08/13/128c77aae4c3d0f863d2f581f39ab8c2.png" alt="image"></p><p>NCF的通用设计结构。首先将用户和物品分别使用one-hot encoding进行表示，接着将经过one-hot encoding得到的稀疏向量进行embedding操作，表示成一个k维空间中的稠密矩阵，之后将用户隐向量和物品隐向量进行拼接并输入到DNN网络中，经过多层感知机后学习得到对应的得分</p><h4 id="3-模型具体结构"><a href="#3-模型具体结构" class="headerlink" title="3.模型具体结构"></a>3.模型具体结构</h4><p>针对这个通用框架，论文提出了三种不同的实现，三种实现可以用一张图来说明：</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/3141e8880060aeab1079ea2e097f3207.png" alt="image"></p><h5 id="GMF（广义矩阵分解）"><a href="#GMF（广义矩阵分解）" class="headerlink" title="GMF（广义矩阵分解）"></a><strong>GMF（广义矩阵分解）</strong></h5><p>考虑到MF模型的一个缺点在于MF仅考虑了简单线性的内积操作，在低维表示空间中，容易出现前文论述的问题，因此，一种设计思路是在MF的基础上做出了一定的改进GMF对应的数学公式如下：</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/ff56d49a0a0e8a8335d4590301ca3a1b.png" alt="image"></p><p>GMF将内积操作替换成原始逐位乘积，与内积不同，该操作是将两个向量的对应位置元素进行乘积，最终的结果仍然为一个k维向量，同时，GMF给予了逐位乘积对应的权重向量<strong>h</strong>。为了使模型更具表现力，GMF在模型中融入了非线性操作，利用Sigmoid函数（a_out）对赋权后的向量进行计算。</p><h5 id="MLP（多层感知器）"><a href="#MLP（多层感知器）" class="headerlink" title="MLP（多层感知器）"></a><strong>MLP（多层感知器）</strong></h5><p>由于 NCF 分别对用户和物品进行了隐表示的学习，因此一种比较直观的做法是通过将物品和用户的隐向量进行简单拼接，再直接进行交互估计。但是，简单的向量连接并没有考虑到用户和项目潜在特征之间的任何交互，这不足以模拟协作过滤效果。为了解决这个问题，本篇论文建议在concat上·添加隐藏层，使用标准 MLP 来学习用户和项目潜在特征之间的交互。从这个意义上说，这样做可以赋予模型很大程度的灵活性和非线性来学习隐向量之间的相互作用，而不是像 GMF 那样只对它们使用固定的元素乘积，具体表达式如下：</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/01ebe70a647efe8c7856f7054f03920b.png" alt="image"></p><h5 id="GMF与MLP组合-NeuMF（神经矩阵分解）"><a href="#GMF与MLP组合-NeuMF（神经矩阵分解）" class="headerlink" title="GMF与MLP组合-NeuMF（神经矩阵分解）"></a>GMF与MLP组合-NeuMF（神经矩阵分解）</h5><p>本篇论文认为GMF模型可以通过设置激活函数Sigmoid和权重向量来获得隐向量的线性表示，而MLP可以通过多层感知机来学习到隐向量的非线性表示，因此，本篇论文开始尝试对两种模型进行组合。</p><p>1）让两个模型共享embedding层获得的隐向量</p><p>优：一定程度降低模型复杂度</p><p>劣：影响模型表现（两个模型的需要设置相同的隐藏空间维度，这样会使得模型的灵活度下降且可能最佳隐藏空间维度可能不相等）</p><p>2)独立学习隐向量(两个模型分别设置单独的Embedding层)表达如下：</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/b8114691075e5c907648217e7ad32198.png" alt="image"></p><h4 id="4-模型实验"><a href="#4-模型实验" class="headerlink" title="4 模型实验"></a>4 模型实验</h4><p>论文通过三个角度进行了试验：</p><p>RQ1 我们提出的NCF方法是否胜过 state-of-the-art 的隐性协同过滤方法？ </p><p>RQ2 我们提出的优化框架（消极样本抽样的logloss）怎样为推荐任务服务？ </p><p>RQ3 更深的隐藏单元是不是有助于对用户项目交互数据的学习？</p><p>评估方案：论文采用了leave-one-out方法评估</p><p>论文将NCF方法与下列方法进行了比较：ItemPop，ItemKNN，BPR，eALS</p><h5 id="RQ1试验结果"><a href="#RQ1试验结果" class="headerlink" title="RQ1试验结果"></a>RQ1试验结果</h5><p><img src="https://file.imgcc.cloud/images/2024/08/13/238ee4000205a001cb5d4503904d2a6a.png" alt="image"></p><p>即NCF效果好于BaseLine模型</p><h5 id="RQ2试验结果"><a href="#RQ2试验结果" class="headerlink" title="RQ2试验结果"></a>RQ2试验结果</h5><p><img src="https://file.imgcc.cloud/images/2024/08/13/635f1b3ba2577f6881920bb4b49dd369.png" alt="image"></p><p>Figure 6 表示将模型看作一个二分类任务并使用logloss作为损失函数时的训练效果。</p><p> Figure7 表示采样率对模型性能的影响（横轴是采样率，即负样本与正样本的比例）。</p><p>最佳采样比约为 3 到 6，过于激进地设置采样率可能会对性能产生不利影响</p><h5 id="RQ3试验结果"><a href="#RQ3试验结果" class="headerlink" title="RQ3试验结果"></a>RQ3试验结果</h5><p><img src="https://file.imgcc.cloud/images/2024/08/13/17a40fc6fffc5486e2047a4794e690c4.png" alt="image"></p><p><img src="https://file.imgcc.cloud/images/2024/08/13/4ffb8544fcc10b06ee9ab6c8cc473d3f.png" alt="image"></p><p>上面的表格设置了两个变量，分别是Embedding的长度K和神经网络的层数，使用类似网格搜索的方式展示了在两个数据集上的结果。增加Embedding的长度和神经网络的层数是可以提升训练效果的。</p><p>TIPS思考：模型在辅助信息的使用方面以及信息特征抽取方面存在不足。神经协同过滤模型使用用户与项目历史行为信息,生成嵌入特征,通过多层感知机模拟用户与项目的交互,解决了一些传统的推荐算法的不足。尽管在性能上有所提升,但是该算法使用的特征信息较为单一,只使用了用户与项目的交互信息,而没有使用其他的辅助信息。辅助信息如用户与项目的属性标签信息对提高模型个性化推荐性能以及缓解系统冷启动具有重要作用,若能将这些信息引入至神经协同过滤模型中,则可以使神经协同过滤模型的推荐性能更好、推荐可解释性更强。</p><p>问题：模型的参数与收敛时间增加、模型无法很好地挖掘多种信息特征、模型对特征信息视为同等重要,消解部分有价值的信息。</p><p>NCF复现 pytorch版本     </p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KNN和K-means算法</title>
      <link href="/posts/b3bbb490.html"/>
      <url>/posts/b3bbb490.html</url>
      
        <content type="html"><![CDATA[<h2 id="KNN和K-means算法"><a href="#KNN和K-means算法" class="headerlink" title="KNN和K-means算法"></a>KNN和K-means算法</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">KNN</th><th style="text-align:center">K-means</th></tr></thead><tbody><tr><td style="text-align:center">目标</td><td style="text-align:center">目标是为了确定一个点的分类</td><td style="text-align:center">目标是为了将一系列点集分成k类</td></tr><tr><td style="text-align:center">算法类别</td><td style="text-align:center">分类算法</td><td style="text-align:center">聚类算法</td></tr><tr><td style="text-align:center">学习类型</td><td style="text-align:center">监督学习，类别是已知的，通过对已知分类的数据进行训练和学习，找到这些不同类的特征，再对未分类的数据进行分类</td><td style="text-align:center">非监督学习，事先不知道数据会分为几类，通过聚类分析将数据聚合成几个群体。聚类不需要对数据进行训练和学习</td></tr><tr><td style="text-align:center">训练数据集</td><td style="text-align:center">训练数据集有label，已经是完全正确的数据</td><td style="text-align:center">训练数据集无label，是杂乱无章的，经过聚类后才变得有点顺序，先无序，后有序</td></tr><tr><td style="text-align:center">训练过程</td><td style="text-align:center">没有明显的前期训练过程</td><td style="text-align:center">有明显的前期训练过程</td></tr><tr><td style="text-align:center">K值结果</td><td style="text-align:center">K值确定后每次结果固定</td><td style="text-align:center">K值确定后每次结果可能不同，从 n个数据对象任意选择 k 个对象作为初始聚类中心，随机性对结果影响较大</td></tr><tr><td style="text-align:center">时间复杂度</td><td style="text-align:center">O（n）</td><td style="text-align:center">O(n<em>k</em>t)，t为迭代次数</td></tr></tbody></table></div><h2 id="K-最近邻算法-KNN"><a href="#K-最近邻算法-KNN" class="headerlink" title="K-最近邻算法(KNN)"></a>K-最近邻算法(KNN)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>K 最近邻（KNN，K-NearestNeighbor）分类算法是数据挖掘分类技术中最简单的方法之一。所谓 K 最近邻，就是 K 个最近的邻居的意思，说的是每个样本都可以用它最接近的 K 个邻近值来代表。 K 最近邻算法就是将数据集合中每一个记录进行分类的方法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>对未知类别属性的数据集中的每个点依次执行以下操作:<br>(1) 计算已知类别数据集中的点与当前点之间的距离;<br>(2) 按照距离递增次序排序;<br>(3) 选取与当前点距离最小的k个点;<br>(4) 确定前k个点所在类别的出现频率;<br>(5) 返回前k个点出现频率最高的类别作为当前点的预测分类</p><h3 id="举一个关于KNN算法的例题"><a href="#举一个关于KNN算法的例题" class="headerlink" title="举一个关于KNN算法的例题"></a>举一个关于KNN算法的例题</h3><p>假设有如下 6 个数据点，其中前 5 个为训练数据，分别有两个特征 x1 和 x2。最后一个数据点是测试数据，需要通过 KNN 算法预测其所属类别。</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">x1</th><th style="text-align:center">x2</th><th style="text-align:center">类别</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">8</td><td style="text-align:center">B</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">？</td></tr></tbody></table></div><p>我们现在需要用 KNN 算法对第 6 个数据点进行分类。假设 K=3，即在训练数据中找三个离第六个数据点最近的点，再根据这三个点的分类来判断第六个数据点的类别。</p><p>首先，需要用欧氏距离计算每个训练数据点和第六个数据点之间的距离：</p><p><img src="https://img-blog.csdnimg.cn/20210402203539984.png" alt="img"></p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">x1</th><th style="text-align:center">x2</th><th style="text-align:center">类别</th><th style="text-align:center">距离</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">A</td><td style="text-align:center">3.605</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">A</td><td style="text-align:center">3.162</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">A</td><td style="text-align:center">1.414</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">B</td><td style="text-align:center">5.099</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">8</td><td style="text-align:center">B</td><td style="text-align:center">2.236</td></tr></tbody></table></div><p>然后，将距离从小到大排序，取达到 K 值的前 K 个数据点：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">x1</th><th style="text-align:center">x2</th><th style="text-align:center">类别</th><th style="text-align:center">距离</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">A</td><td style="text-align:center">1.414</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">A</td><td style="text-align:center">3.162</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">8</td><td style="text-align:center">B</td><td style="text-align:center">2.236</td></tr></tbody></table></div><p>最后，统计前 K 个数据点中类别最多的类别，将该类别作为第六个数据点的预测类别。在这个例子中，前 K 个数据点中 A 的数量为 2，B 的数量为 1，因此第六个数据点被预测为 A 类。</p><p>这就是 KNN 算法的基本流程，通过计算距离、排序和统计来判断新数据点的类别。在实际应用中需要根据不同的场景来选择合适的距离度量方法和 K 值，从而来达到最好的分类效果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码依据步骤而写，从菜鸟教程上找理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练数据集</span></span><br><span class="line">X_train = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="string">&#x27;A&#x27;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">6</span>, <span class="string">&#x27;A&#x27;</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">8</span>, <span class="string">&#x27;B&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据集</span></span><br><span class="line">X_test = [<span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 欧氏距离计算函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euclidean_distance</span>(<span class="params">x1, x2</span>):</span><br><span class="line">    distance = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x1)):</span><br><span class="line">        distance += (x1[i] - x2[i]) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(distance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># KNN 算法实现函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knn</span>(<span class="params">X_train, X_test, k</span>):</span><br><span class="line">    <span class="comment"># 保存距离及其类别的列表</span></span><br><span class="line">    distances = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练数据集，计算每个样本与测试数据之间的距离，并保存距离及其类别</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(X_train)):</span><br><span class="line">        dist = euclidean_distance(X_train[i][:<span class="number">2</span>], X_test)</span><br><span class="line">        label = X_train[i][-<span class="number">1</span>]</span><br><span class="line">        distances.append((dist, label))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将距离列表按照距离从小到大排序</span></span><br><span class="line">    distances.sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出前 K 个距离最近的点</span></span><br><span class="line">    k_nearest_neighbors = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        k_nearest_neighbors.append(distances[i][-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 统计前 K 个点中出现次数最多的类别，即为测试数据的预测类别</span></span><br><span class="line">    most_common = Counter(k_nearest_neighbors).most_common(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> most_common[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 K=3，将测试数据分类</span></span><br><span class="line">predicted_class = knn(X_train, X_test, k=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出预测结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Predicted class for X_test is:&quot;</span>, predicted_class)</span><br></pre></td></tr></table></figure><p>代码解析：</p><p>1.首先定义了训练数据集 X_train 和测试数据集 X_test。<br>2.定义了一个欧氏距离计算函数 euclidean_distance()，用于计算两个数据点之间的欧氏距离。<br>3.定义了 KNN 算法实现函数 knn()，其中按照流程先计算所有训练数据点与测试数据之间的距离，然后将距离从小到大排序，并选出前 K    个距离最近的数据点，统计这些数据点中每个类别出现的次数并找到出现次数最多的那个类别，即为测试数据的预测类别。<br>4.在主程序中调用 knn() 函数，假设 K=3，将测试数据分类，并输出预测结果。</p><p>图像代码不过多阐述</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/71493627e805d359646b2fd43a18bd6e.png" alt="image"></p><h2 id="K均值算法-K-means"><a href="#K均值算法-K-means" class="headerlink" title="K均值算法(K-means)"></a>K均值算法(K-means)</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>聚类算法，将一堆数据划分成到不同的组中。根据样本特征的相似度或距离远近，将其划分成若干个类。</p><p>聚类：物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。由聚类所生成的簇是一组数据对象的集合，这些对象与同一个簇中的对象彼此相似，与其他簇中的对象相异。</p><p> 簇：本算法中可以理解为，把数据集聚类成 k 类，即 k 个簇。 </p><p>质心：指各个类别的中心位置，即簇中心。</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li>从数据中选择k个对象作为初始聚类中心</li><li>计算每个聚类对象到聚类中心的距离来划分</li><li>再次计算每个聚类中心</li><li>计算标准测度函数，直到达到最大迭代次数或者满足收敛条件，则停止，否则，继续2操作</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">复杂度</span><br><span class="line">我们先看下伪代码：</span><br><span class="line"></span><br><span class="line">获取数据 n 个 m 维的数据</span><br><span class="line">随机生成 K 个 m 维的点</span><br><span class="line"><span class="keyword">while</span>(t)</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span>;j &lt; k;j++)</span><br><span class="line">            计算点 i 到类 j 的距离</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">        <span class="number">1.</span> 找出所有属于自己这一类的所有数据点</span><br><span class="line">        <span class="number">2.</span> 把自己的坐标修改为这些数据点的中心点坐标</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>时间复杂度： $O(tknm)$，其中，t 为迭代次数，k 为簇的数目，n 为样本点数，m 为样本点维度。</p><p>空间复杂度： $O(m(n+k))$，其中，k 为簇的数目，m 为样本点维度，n 为样本点数。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>容易理解，聚类效果不错，虽然是局部最优， 但往往局部最优就够了；</li><li>处理大数据集的时候，该算法可以保证较好的伸缩性；</li><li>当簇近似高斯分布的时候，效果非常不错；</li><li>算法复杂度低。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>K 值需要人为设定，不同 K 值得到的结果不一样；</li><li>对初始的簇中心敏感，不同选取方式会得到不同结果；</li><li>对异常值敏感；</li><li>样本只能归为一类，不适合多分类任务；</li><li>不适合太离散的分类、样本类别不平衡的分类、非凸形状的分类。</li></ul><h3 id="举一个关于K-means算法的例题"><a href="#举一个关于K-means算法的例题" class="headerlink" title="举一个关于K-means算法的例题"></a>举一个关于K-means算法的例题</h3><p>如果簇的数目k=2，根据下表数据（n=8）行数据，按照k-means算法，写出每次迭代过程以及最终得到簇的数据所在的序号的集合。</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">属性1</th><th style="text-align:center">属性2</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">5</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table></div><p>提示：（1）第一次迭代先随机找两行数据，如第一行和第三行当为初始点。</p><p>​            （2）计算距离，可以用欧式距离（上文提到过）</p><h3 id="手写推演"><a href="#手写推演" class="headerlink" title="手写推演"></a>手写推演</h3><p><img src="https://file.imgcc.cloud/images/2024/08/13/c3bd2842f93e58927707150294bc0bbb.png" alt="image"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 KMeans 算法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KMeans</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k=<span class="number">2</span>, max_iter=<span class="number">100</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.k = k</span><br><span class="line">        <span class="variable language_">self</span>.max_iter = max_iter</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练模型函数，将数据集分为 k 个簇，并返回每个数据点所属的簇的序号</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X</span>):</span><br><span class="line">        centroids = X[np.random.choice(<span class="built_in">len</span>(X), <span class="variable language_">self</span>.k, replace=<span class="literal">False</span>)] <span class="comment"># 随机选择 k 个数据点作为簇的初始中心</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.max_iter):</span><br><span class="line">            distances = np.<span class="built_in">sum</span>((X - centroids[:, np.newaxis]) ** <span class="number">2</span>, axis=<span class="number">2</span>) <span class="comment"># 计算每个数据点到各个簇中心的距离</span></span><br><span class="line">            labels = np.argmin(distances, axis=<span class="number">0</span>) <span class="comment"># 将每个数据点归属到距离最近的簇</span></span><br><span class="line">            new_centroids = np.array([X[labels == j].mean(axis=<span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.k)]) <span class="comment"># 计算新的簇中心位置</span></span><br><span class="line">            <span class="keyword">if</span> np.allclose(new_centroids, centroids): <span class="comment"># 如果新中心和旧中心相同，则算法收敛</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            centroids = new_centroids <span class="comment"># 更新中心</span></span><br><span class="line">        <span class="keyword">return</span> labels</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 定义数据集</span></span><br><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">3</span>], [<span class="number">5</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 KMeans 模型对象，设置 k=2</span></span><br><span class="line">kmeans = KMeans(k=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型并输出每个数据点所属的簇的序号</span></span><br><span class="line">labels = kmeans.fit(X)</span><br><span class="line"><span class="built_in">print</span>(labels)</span><br></pre></td></tr></table></figure><p>代码解析：</p><p>1.定义 KMeans 算法类 KMeans，其中包括初始化函数 <strong>init</strong>() 和训练模型函数 fit()。在 fit() 函数中，首先随机选择 k 个数据点作为初始簇中心，然后迭代若干次，每次计算所有数据点到各个簇中心的距离，将每个数据点归属到距离最近的簇，并计算新的簇中心位置；如果新中心和旧中心相同，则算法收敛，停止迭代。<br>2.定义数据集 X。<br>3.初始化 KMeans 模型对象 kmeans，并将 k 值设置为 2。<br>训练模型并输出每个数据点所属的簇的序号。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法</title>
      <link href="/posts/2a27add3.html"/>
      <url>/posts/2a27add3.html</url>
      
        <content type="html"><![CDATA[<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><h3 id="二维梯度下降"><a href="#二维梯度下降" class="headerlink" title="二维梯度下降"></a>二维梯度下降</h3><h4 id="背景引入"><a href="#背景引入" class="headerlink" title="背景引入"></a>背景引入</h4><p>​        梯度下降法（gradient descent），又名最速下降法（steepest descent）是求解无约束最优化问题最常用的方法，它是一种迭代方法，每一步主要的操作是求解目标函数的梯度向量，将当前位置的负梯度方向作为搜索方向（因为在该方向上目标函数下降最快，这也是最速下降法名称的由来）。 </p><p>​        梯度下降法特点：==越接近目标值，步长越小，下降速度越慢。==</p><p>​        梯度下降法的基本思想可以类比为一个下山的过程。</p><p>​        假设这样一个场景：一个人被困在山上，需要从山上下来(找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低；因此，下山的路径就无法确定，必须利用自己周围的信息一步一步地找到下山的路。这个时候，便可利用梯度下降算法来帮助自己下山。怎么做呢，首先以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着下降方向走一步，然后又继续以当前位置为基准，再找最陡峭的地方，再走直到最后到达最低处；同理上山也是如此，只是这时候就变成梯度上升算法了</p><p>​        梯度下降的基本过程就和下山的场景很类似。</p><p>​        首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释)<br>所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。</p><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>所谓最快下降方案，无疑是求函数图像中，某点的切线的斜率，函数的变化率</p><p>1.单变量的微分，函数只有一个变量时</p><p>2.多变量的微分，当函数有多个变量的时候，即分别对每个变量进行求微分</p><p>换个方式想想，人想要最快下山，是不是要从最抖的地方开始走，梯度的方向是函数在给定点上升最快的方向，那么梯度的反方向就是函数在给定点下降最快的方向，那么沿着梯度走不但能到终点，而且过程最快</p><p>由此，我们开始剖析公式</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>初始：</p><p>$Θ^1=Θ^0-α*J′(Θ^0)→evaluatedatΘ^0$</p><p>$Θ^0$代表起始位置，$Θ^{0+1}$代表下一个状态的位置</p><p>α代表步长，即也就是学习率，如果学习率不合适可能会导致发生错误</p><p>由此推之</p><p>$Θ^{n+1}=Θ^n-α*J′(Θ^n)→evaluatedatΘ^n$</p><p>注意：</p><ul><li>当靠近极小值时收敛速度减慢</li><li>下降过程可能会出现 “之字形” 地下降</li><li>代码层面需要设置停止运算条件直到到达指定精度或者指定运算次数停止</li></ul><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>用梯度下降法求 $y=x^2/2-2x$的极值。<br>提示：初始值$x~0=-4$ 学习率 $η=0.9$，终止条件：Δx&lt;ε=0.01。</p><h4 id="手写推演："><a href="#手写推演：" class="headerlink" title="手写推演："></a>手写推演：</h4><p><img src="https://file.imgcc.cloud/images/2024/08/13/ced32a04871b81e1017887b05264cd7b.png" alt="image"></p><h4 id="代码和运行结果："><a href="#代码和运行结果：" class="headerlink" title="代码和运行结果："></a>代码和运行结果：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数 y = x^2 / 2 - 2x</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="number">2</span> / <span class="number">2</span> - <span class="number">2</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数 y 对 x 的导数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfunc</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x - <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义梯度下降函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">x0, eta, epsilon</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    x = x0</span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    delta_x = epsilon + <span class="number">1</span></span><br><span class="line">    result_x = [x]</span><br><span class="line">    result_y = [func(x)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代更新参数，直到满足终止条件</span></span><br><span class="line">    <span class="keyword">while</span> delta_x &gt; epsilon:</span><br><span class="line">        <span class="comment"># 计算导数</span></span><br><span class="line">        vd = dfunc(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新速度和位置</span></span><br><span class="line">        v = -eta * vd</span><br><span class="line">        x += v</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算当前点与上一个点的距离</span></span><br><span class="line">        delta_x = <span class="built_in">abs</span>(result_x[-<span class="number">1</span>] - x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存每次迭代得到的结果</span></span><br><span class="line">        result_x.append(x)</span><br><span class="line">        result_y.append(func(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (result_x, result_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置初始值、学习率和终止条件</span></span><br><span class="line">x0 = -<span class="number">4</span></span><br><span class="line">eta = <span class="number">0.9</span></span><br><span class="line">epsilon = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用梯度下降函数求解</span></span><br><span class="line">result_x, result_y = gradient_descent(x0, eta, epsilon)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;通过梯度下降法求得的极值点横坐标为：&quot;</span>, result_x[-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终误差：&quot;</span>, <span class="built_in">abs</span>(result_y[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制函数图像</span></span><br><span class="line">x = [i / <span class="number">10</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">40</span>, <span class="number">60</span>)]</span><br><span class="line">y = [func(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制梯度下降过程图像</span></span><br><span class="line">plt.plot(result_x, result_y, color=<span class="string">&#x27;r&#x27;</span>, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加标题</span></span><br><span class="line">plt.title(<span class="string">&quot;y = x^2 / 2 - 2x, η = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(eta))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如图</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/c907a367714f1061380076946817526c.png" alt="image"></p><h3 id="梯度下降三种形式（BGD，SGD，MBGD）"><a href="#梯度下降三种形式（BGD，SGD，MBGD）" class="headerlink" title="梯度下降三种形式（BGD，SGD，MBGD）"></a>梯度下降三种形式（BGD，SGD，MBGD）</h3><h4 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h4><p>批量梯度下降法每次都使用训练集中的所有样本更新参数。它得到的是一个全局最优解，但是每迭代一步，都要用到训练集所有的数据，如果很大，那么迭代速度就会变得很慢。 优点：可以得出全局最优解。 缺点：样本数据集大时，训练速度慢。</p><h4 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h4><p>由于批梯度下降每跟新一个参数的时候，要用到所有的样本数，所以训练速度会随着样本数量的增加而变得非常缓慢。随机梯度下降正是为了解决这个办法而提出的。它是利用每个样本的损失函数对θ求偏导得到对应的梯度，来更新θ</p><p>　随机梯度下降是通过每个样本来迭代更新一次，对比上面的批量梯度下降，迭代一次需要用到所有训练样本（<strong>往往如今真实问题训练数据都是非常巨大</strong>），一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。<strong>但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</strong></p><h4 id="小批量梯度下降法"><a href="#小批量梯度下降法" class="headerlink" title="小批量梯度下降法"></a>小批量梯度下降法</h4><p>我们从上面两种梯度下降法可以看出，其各自均有优缺点，那么能不能在两种方法的性能之间取得一个折衷呢？<strong>即，算法的训练过程比较快，而且也要保证最终参数训练的准确率，</strong>而这正是小批量梯度下降法（Mini-batch Gradient Descent，简称MBGD）的初衷。</p><h3 id="拓展：二维延展至三维梯度下降"><a href="#拓展：二维延展至三维梯度下降" class="headerlink" title="拓展：二维延展至三维梯度下降"></a>拓展：二维延展至三维梯度下降</h3><p>举例</p><p>假设有个函数</p><p>$f(x,y)=x^2+y^2$</p><p>微分得</p><p>$f_x’(x,y)=2x$   $f_x’(x,y)=2y$</p><p>假设初始起点为(5,5)，步长α=0.4</p><p>以此类推$Θ^1=Θ^0−α*J(Θ)=(5,5)−0.2∗(10,10)=(3.0,3.0)$</p><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">ax = plt.figure().add_subplot(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x+y*y</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfx</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfy</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*x</span><br><span class="line">a=<span class="number">0.2</span>   <span class="comment">#步长</span></span><br><span class="line">x,y=<span class="number">5</span>,<span class="number">5</span> <span class="comment">#初始x,y位置</span></span><br><span class="line">gx=[x]   </span><br><span class="line">gy=[y]   </span><br><span class="line">gz=[f(x,y)]</span><br><span class="line">fcu=fch=f(x,y)</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="comment">#算法</span></span><br><span class="line"><span class="keyword">while</span> ans &lt;<span class="number">100</span> <span class="keyword">and</span> fch&gt; <span class="number">1e-10</span>: <span class="comment">#当次数小于100次或者函数变化小于1e-10就继续进行任务</span></span><br><span class="line">    ans+=<span class="number">1</span></span><br><span class="line">    x=x-a*dfx(x)</span><br><span class="line">    y=y-a*dfy(y)</span><br><span class="line">    tmp=f(x,y)</span><br><span class="line">    fch=<span class="built_in">abs</span>(fcu-tmp)</span><br><span class="line">    fcu=tmp</span><br><span class="line">    gx.append(x)</span><br><span class="line">    gy.append(y)</span><br><span class="line">    gz.append(fcu)</span><br><span class="line"><span class="comment"># print(&quot;&#123;:.10f&#125;&quot;.format(gx[3])) #无限接近0</span></span><br><span class="line">X=np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">Y=np.arange(-<span class="number">5</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">Z=np.array(f(X,Y))</span><br><span class="line">ax.plot(X,Y,Z)</span><br><span class="line">ax.plot(gx,gy,gz)</span><br><span class="line">ax.scatter(gx,gy,gz)</span><br><span class="line">plt.title(<span class="string">&quot;$f(x,y)=x^2+y^2$\n$a=%.2f$&quot;</span> % a)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果如图</p><p><img src="https://file.imgcc.cloud/images/2024/08/13/68eab393b299ed6d49e022a78b721628.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
